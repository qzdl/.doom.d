:PROPERTIES:
:ID:       362f5822-9b91-47ad-989c-68a5489303d5
:END:
#+title: Emacs Configuration
#+property: header-args :tangle yes



* about this configuration
** metaprogramming
*** dice function
#+begin_src emacs-lisp
(defun dice ()
  (interactive)
  (let ((n (1+ (random* 6))))
    (message "%s" n)
     n))
#+end_src

#+RESULTS:
: dice

*** meta-eval (funcall '(message "a"))

would be nice to have this, but hey
#+begin_src emacs-lisp :tangle no
(funcall '(message "a"))
#+end_src

not valid, use
#+begin_src emacs-lisp :tangle no
(funcall #`(message "a"))
#+end_src
or
*** meta-eval splice funcall
*** basic
*** insert ,value
*** splice ,@values
*** alternative
*** concrete usage, anonymous macro kwargs splicing
#+begin_src emacs-lisp :tangle no
(defun dice ()
  (1+ (random* 6)))

(funcall 'list
         :title "const value"
         (when (= 1 (dice)) :shoo)
         (when (= 1 (dice)) 'doo))

(cl-loop for i from 1 to 6
         for d = (dice)
         for f = `(lambda () (list :title "const value"
                              ,@(when (= 1 d) '(:id "yaaa"))))
         collect (message "%s | %s | %s | %s |\n" i d f (funcall f)))
#+end_src

#+RESULTS:
| 1 | 2 | (lambda nil (list :title const value))          | (:title const value)          |
| 2 | 4 | (lambda nil (list :title const value))          | (:title const value)          |
| 3 | 1 | (lambda nil (list :title const value :id yaaa)) | (:title const value :id yaaa) |
| 4 | 6 | (lambda nil (list :title const value))          | (:title const value)          |
| 5 | 2 | (lambda nil (list :title const value))          | (:title const value)          |
| 6 | 4 | (lambda nil (list :title const value))          | (:title const value)          |

* globals
** guix-autoload
#+begin_src emacs-lisp
(guix-emacs-autoload-packages)
#+end_src
** vars :vars:
*** doom id
#+begin_src emacs-lisp
(setq user-full-name "Samuel Culpepper"
      user-mail-address "samuel@samuelculpepper.com")
(setq qz/capture-title-timestamp-roam "20210813T161035Z-${slug}.org")
#+end_src

#+RESULTS:
: 20210813T161035Z-${slug}.org
*** hostname specific; fonts
#+begin_src emacs-lisp
(cond
  ((string-equal system-name "qzdl") (setq qz/font-default 32))
  ((string-equal system-name "donutrust") (setq qz/font-default 16))
  (t (setq qz/font-default 16)))
#+end_src

#+RESULTS:
: 16

*** epg program
#+begin_src emacs-lisp
(setq epg-gpg-program "gpg")
#+end_src

#+RESULTS:
: gpg

#+RESULTS:
: 16
*** authinfo
#+begin_src emacs-lisp
(load-file "~/.doom.d/private/authinfo.el")
#+end_src

#+RESULTS:
: t

** global bindings :kbd:
These Key Binds Are focused around ergonomics more than mnemonics
*** Mouse jumping
#ERGO
<link-to-elisp-doc 'better-jumper-jump-backwards>
#+begin_src emacs-lisp
  (map! "<mouse-8>" 'better-jumper-jump-backward)
  (map! "<mouse-9>" 'better-jumper-jump-forward)
#+end_src

#+RESULTS:
*** unset {C-z} to eqiv of vim's {O} -> also stop EXWM from hanging
this bind is a DOOM emacs function, lilke )
#+begin_src emacs-lisp
(map! "C-z" #'+default/newline-above)
#+end_src

#+RESULTS:
*** zap-up-to-char on {M-z} and {C-x C-z}
#+begin_src emacs-lisp
(map! "M-z" #'zap-up-to-char) ;; like dt<CHAR> in vim
(map! "C-x C-z" #'zap-up-to-char)
#+end_src

#+RESULTS:

*** redo {C-?}
#+begin_src emacs-lisp
(map! "C-?" #'undo-redo)
#+end_src

#+RESULTS:

*** Switch macro {C-x C-k} and kill-buffer {C-x k}
#+begin_src emacs-lisp
(map! "C-x C-k" #'kill-this-buffer)
(map! "C-x k" #'kmacro-keymap)
#+end_src

#+RESULTS:

*** HJKL Window control
#+begin_src emacs-lisp
(map! "s-h" #'windmove-left)
(map! "s-j" #'windmove-down)
(map! "s-k" #'windmove-up)
(map! "s-l" #'windmove-right)
#+end_src

#+RESULTS:
*** Switch delete-blank-lines {C-x C-o} and other-window {C-x o}
#+begin_src emacs-lisp
(map! "C-x C-o" #'ace-window)
(map! "C-x o" #'delete-blank-lines)
#+end_src

#+RESULTS:

*** Buffer control
#+begin_src emacs-lisp
(map! "s-n" #'next-buffer)
(map! "s-p" #'previous-buffer)
#+end_src

#+RESULTS:

*** Switch {C-x} and {C-u}
A tip associated with Dvorak, that is equally charming without the dvorak
keyboard layout. This stellar advice came from [[https://www.emacswiki.org/emacs/DvorakKeyboard][EmacsWiki: Dvorak Keyboard]].
#+begin_src emacs-lisp
(define-key key-translation-map [?\C-x] [?\C-u])
(define-key key-translation-map [?\C-u] [?\C-x])
#+end_src

#+RESULTS:
: [24]

*** Shell pop
#+begin_src emacs-lisp
(map! "C-x C-'" #'+vterm/toggle)
#+end_src

#+RESULTS:

**** TODO Abstract this to a ~user-shell/toggle~ function
incase the shell needs to be changed
*** ROT13 buffer
#+begin_src emacs-lisp
(map! "s-B" 'toggle-rot13-mode)
#+end_src

#+RESULTS:
*** roam insert todo on {s-i}
can just be easier this way
#+begin_src emacs-lisp
(map! "s-i" #'qz/roam-capture-todo)
#+end_src

**** github issue
***** Brief Abstract
A UX note for text suggestion in `completing-read` and/or 'pass-through'.

It's nice to have rapid-fire sometimes.

The implementation might not be right for inclusion with

***** Long Description
Binding; I use ~C-c n i~ for ~org-roam-node-insert~, so an easy jump to this new immediate insert is

In the implementation below, I've adapted `doom-thing-at-point-or-region`, to return what the user is 'looking at', and the positional information used to retrieve it.


which dispatches cond for
- a string value of given argument `thing`
- a `region-active-p`; and the containing

- NOTE: I haven't gone too deep on recovering the internals of the cl-generic dispatch used in `xref-backend-identifier-at-point`, so I've taken the cheat-path of referencing
***** Proposed Implementation (if any)

#+begin_src elisp
(defun qz/thing-at-point-or-region-and-region (&optional thing prompt)
  "Grab the current selection, THING at point, or xref identifier at point.

Returns THING if it is a string. Otherwise, if nothing is found at point and
PROMPT is non-nil, prompt for a string (if PROMPT is a string it'll be used as
the prompting string). Returns nil if all else fails.

NOTE: Don't use THING for grabbing symbol-at-point. The xref fallback is smarter
in some cases."
  (declare (side-effect-free t))
  (cond ((stringp thing)
         thing)
        ((doom-region-active-p)
         (cons (buffer-substring-no-properties (region-beginning) (region-end))
               (cons (region-beginning)
                     (region-end))))
        (thing
         (cons (thing-at-point thing t)
               (bounds-of-thing-at-point thing)))
        ((require 'xref nil t)
         ;; Eglot, nox (a fork of eglot), and elpy implementations for
         ;; `xref-backend-identifier-at-point' betray the documented purpose of
         ;; the interface. Eglot/nox return a hardcoded string and elpy prepends
         ;; the line number to the symbol.
         (let* ((val
                 (if (memq (xref-find-backend) '(eglot elpy nox))
                     (thing-at-point 'symbol t)
                   ;; A little smarter than using `symbol-at-point', though in most
                   ;; cases, xref ends up using `symbol-at-point' anyway.
                   (xref-backend-identifier-at-point (xref-find-backend)))))
           (cons val (bounds-of-thing-at-point 'symbol))))
        (prompt
         (read-string (if (stringp prompt) prompt "")))))

(defun qz/org-roam-node-insert (&optional filter-fn pass-thru)
  "Find an Org-roam file, and insert a relative org link to it at point.
Return selected file if it exists.
If LOWERCASE is non-nil, downcase the link description.
FILTER-FN is the name of a function to apply on the candidates
which takes as its argument an alist of path-completions."
  (interactive)
  (unwind-protect
      ;; Group functions together to avoid inconsistent state on quit
      (atomic-change-group
        (let* ((pt (qz/thing-at-point-or-region-and-region))
               (beg (set-marker (make-marker) (car (cdr pt))))
               (end (set-marker (make-marker) (cdr (cdr pt))))
               (region-text (org-link-display-format
                             (substring-no-properties (car pt))))
               (node (if pass-thru
                         (or (org-roam-node-from-title-or-alias region-text)
                             (org-roam-node-create :title region-text))
                       (org-roam-node-read region-text filter-fn)))
               (description (or (and node region-text (org-roam-node-title node))
                                region-text)))
          (if (org-roam-node-id node)
              (progn
                (when region-text
                  (delete-region beg end)
                  (set-marker beg nil)
                  (set-marker end nil))
                (insert (org-link-make-string
                         (concat "id:" (org-roam-node-id node))
                         description)))
            (funcall
              `(lambda ()
                 (org-roam-capture-
                  :node node
                  ,@(when pass-thru '(:keys "n")) ; ; [[id:bc3c61d4-d720-40a8-9018-6357f05ae85e][roam-capture-template]]
                  :props (append
                          (when (and beg end)
                            (list :region (cons beg end)))
                          (list :insert-at (point-marker)
                                :link-description description
                                :finalize 'insert-link))))))))
    (deactivate-mark)))
#+end_src
***** Please check the following:

- [ ] No similar feature requests




#+RESULTS:

*** expand-region on {s-=}
#+begin_src emacs-lisp
(map! "s-=" #'er/expand-region)
#+end_src
*** git-link on {C-c v C-l}

#+begin_src emacs-lisp
(map! "C-c v C-l" 'git-link)
#+end_src

#+RESULTS:

*** TODO bookmarks
** functions :func:
*** UTC Timestamp
#+begin_src emacs-lisp
(defun qz/utc-timestamp ()
  (format-time-string "%Y%m%dT%H%M%SZ" (current-time) t))
#+end_src

#+RESULTS:
: qz/utc-timestamp

*** custom popup qz/buffer-popup
#+begin_src emacs-lisp
(defvar qz/buffer-popup-minor-mode-map
  (let ((kmap (make-sparse-keymap)))
    (set-keymap-parent kmap text-mode-map)
    (define-key kmap (kbd "C-c C-c") #'qz/buffer-popup-commit)
    (define-key kmap (kbd "C-c C-k") #'qz/buffer-popup-abort)
    kmap))

(defcustom qz/buffer-popup-window-config
  '(+popup-display-buffer-stacked-side-window-fn)
  ;;  '((display-buffer-reuse-window display-buffer-split-below-and-attach)    (inhibit-same-window . t) (window-height . 0.25))
  "adjust the behaiour of the popup window

totally stolen from <link-to-elisp-doc 'pdf-annot-edit-contents-display-buffer-action>'")

(define-minor-mode qz/buffer-popup-minor-mode
  "Active when editing the contents of qz/buffer-popup."
  nil nil nil
  (when qz/buffer-popup-minor-mode
    (message "%s"
             (substitute-command-keys
              "Press \\[qz/buffer-popup-commit] to commit your changes, \\[qz/buffer-popup-abort] to abandon them."))))

(put 'qz/buffer-popup-minor-mode 'permanent-local t)



;; FIXME make this better for general shit
(defun qz/buffer-popup-finalize (save? &optional kill backfill)
  (setq qz/buffer-popup-last-value
        (cond
         ((and kill backfill) backfill)
         (t (with-current-buffer qz/buffer-popup-current-or-last
              (buffer-substring-no-properties (point-min) (point-max))))))
  (dolist (win (get-buffer-window-list))
    (quit-window t win))
  (if qz/buffer-popup-final
      (funcall qz/buffer-popup-final))
  (message "%s" qz/buffer-popup-last-value))

(defun qz/buffer-popup-commit ()
  (interactive)
  (qz/buffer-popup-finalize t))

(defun qz/buffer-popup-abort ()
  (interactive)
  (qz/buffer-popup-finalize nil t))


(defun qz/buffer-popup-create ()
  (interactive)
  (select-window
   (display-buffer
    (with-current-buffer (get-buffer-create
                          (format "*Edit stuff %s*"
                                  (buffer-name)))
      (qz/buffer-popup-minor-mode 1)
      (org-mode)
      (setq qz/buffer-popup-current-or-last (current-buffer)))
    qz/buffer-popup-window-config))
  qz/buffer-popup-current-or-last)
#+end_src

#+RESULTS:
: qz/buffer-popup-create

*** TODO insert var
stealing from 'describe-variable -> cool to insert the value of named var, from completing read
#+begin_src emacs-lisp
(defun qz/insert-var ()
  (interactive)
  (completing-read
   (format-prompt "Describe variable" (and (symbolp (variable-at-point) (variable-at-point)))
                  #'help--symbol-completion-table
                  (lambda (vv)
                    ;; In case the variable only exists in the buffer
                    ;; the command we switch back to that buffer before
                    ;; we examine the variable.
                    (with-current-buffer orig-buffer
                      (or (get vv 'variable-documentation)
                          (and (boundp vv) (not (keywordp vv))))))
                  t nil nil
                  (if (symbolp v) (symbol-name v)))))
#+end_src

*** contract file name
keep it relative; sorry Ayn
#+begin_src emacs-lisp
(defun qz/contract-file-name (file)
  "turn an objective path to a relative path to homedir `~/`"
  (replace-regexp-in-string(expand-file-name "~/") "~/" file))
#+end_src

#+RESULTS:
: qz/contract-file-name

*** force xkb layout
#+begin_src emacs-lisp
(defun qz/nocap ()
  (interactive)
  (async-shell-command "setxkbmap -model thinkpad -layout us -option ctrl:nocaps"))
#+end_src

#+RESULTS:
: qz/nocap

*** toggle between non-nil -> [ 0 | 1 ], [ on | off ]
This function is used for quality of life in ensuring correct bottom values are
used when toggling modes; the set of activation values are not necessarily using
~[t | nil]~, but can be =[(t n>0) | n<=0]=, which can throw a spanner in the
works for a regular style ~(mode (setq toggle (not toggle)))~ type of
arrangement, given ~[t | nil]~.

An example of this can be found in [[Time in the modeline]], or [[Toggle
ERROR_ROLLBACK]]. Equal is used here to coerce non-numeric arguments into
something that will toggle.
#+begin_src emacs-lisp
(defun qz/toggle-1->0 (n)
  (if (equal 1 n) 0 1))

(defun qz/toggle-on->off (n)
  (if (equal 1 n) "on" "off"))
#+end_src

#+RESULTS:
: qz/toggle-on->off

*** pprint with ~cl-prettyprint~
[[https://stackoverflow.com/questions/3552106/pprint-in-emacs-lisp][elisp - PPRINT in Emacs Lisp? - Stack Overflow]]

#+begin_src emacs-lisp
(defun qz/pprint (form &optional output-stream)
  (princ (with-temp-buffer
           (cl-prettyprint form)
           (buffer-string))
         output-stream))
#+end_src

#+RESULTS:
: qz/pprint

*** fix [[id:1192b891-d866-458b-a99d-a56d01d8cee1][bluetooth headphones]]
#+begin_src emacs-lisp
(defun qz/bt-a2dp ()
  (interactive)
  (shell-command "pactl set-card-profile bluez_card.2C_41_A1_87_20_BA a2dp_sink"))

(defun qz/bt-headphone-off ()
  (interactive)
  (async-shell-command "bluetoothctl disconnect 2C:41:A1:87:20:BA"))

(defun qz/bt-headphone-on ()
  (interactive)
  (async-shell-command "bluetoothctl connect 2C:41:A1:87:20:BA"))
#+end_src

#+RESULTS:
: qz/bt-headphone-on
*** TODO mouse button fuckery :func:
found some rabbit hole when playing with org-noter
- #'read-event
  + #'org-noter--get-precise-info
  + reads the row of the posn from the event, sums offset, maps to pdf position.
    good job org-noter developer
- #'event-start
- #'posn
- #'mouse-pixel-position

what's strange to me is that #'qz/event-line-offset, which triggers
#'read-event, will report a consistent range numbers, but #'thing-at-point will
often start sending out lower numbers.
- this might be because of posn information around headings, taking some number
  relative to an org heading?
#+begin_src emacs-lisp

;;  (org-noter-insert-note (org-noter--get-precise-info))
;; ~read-event~ is cool -> org-noter--get-precise-info

(defun qz/event-line-offset ()
  "testing click at point functions'"
  (interactive)
  (message (number-to-string (cdr (posn-col-row  (event-start  (read-event "Click!")))))))

(defun qz/thing-at-point ()
  (interactive)
    (cdr (posn-col-row
      (let* ((m (mouse-pixel-position))
             (xy (cdr m)))
        (posn-at-x-y (car xy) (cdr xy) (car m))))))

;;(message (number-to-string (car (posn-col-row (posn-at-point (point)))))))

;;(map! "C-<down-mouse-1>" #'qz/thing-at-point)

;;'(#<window 832 on config.org> ; window
;;  5080        ; area-or-pos
;;  (413 . 966) ; (x . y)
;;  0           ; timestamp
;;  nil         ; object
;;  5080        ; pos
;;  (41 . 50)   ; (col . row)
;;  nil         ; image
;;  (333 . 16)  ; (dx . dy)
;;  (10 . 19))  ; (width . height)
#+end_src

#+begin_src emacs-lisp
(defun qz/org-noter--get-precise-info ()
                                        ;(org-noter--with-valid-session
  (let ((window (org-noter--get-doc-window))
        (mode (org-noter--session-doc-mode session))
        event)
    (with-selected-window window
      (while (not (and (eq 'mouse-1 (car event))
                       (eq window (posn-window (event-start event)))))
        (setq event (read-event "Click where you want the start of the note to be!")))
      (cond
       ((run-hook-with-args-until-success 'org-noter--get-precise-info-hook mode))

       ((eq mode 'pdf-view-mode)
        (if (pdf-view-active-region-p)
            (cadar (pdf-view-active-region))
          (org-noter--conv-page-scroll-percentage
           (+ (window-vscroll)
              (cdr (posn-col-row (event-start event)))))))

       ((eq mode 'doc-view-mode)
        (org-noter--conv-page-scroll-percentage
         (+ (window-vscroll)
            (cdr (posn-col-row (event-start event))))))

       ((eq mode 'nov-mode)
        (if (region-active-p)
            (min (mark) (point))
          (posn-point (event-start event))))))));)

;;(qz/org-noter--get-precise-info)
#+end_src

#+RESULTS:
: qz/org-noter--get-precise-info
** emacs server :init:
#+begin_src emacs-lisp
(server-start)
#+end_src
** lock
#+begin_src emacs-lisp
(defun qz/i3lock ()
  (interactive)
        (async-shell-command "exec --no-startup-id mpc pause; exec --no-startup-id pauseallmpv; exec rm -f /tmp/screenshot.png /tmp/out.png && scrot /tmp/screenshot.png && ~/git/corrupter/corrupter /tmp/screenshot.png /tmp/out.png && i3lock -i /tmp/out.png"))

#+end_src

#+RESULTS:
: qz/i3lock

* [[id:2c8c6541-74a2-4e13-af5b-b463a429937d][EXWM]]
big thanks to https://github.com/akirak/emacs.d

** init; xrandr commands
I've been thinking about some declarative way to associate host->port->device
- would be nice to have a fallback tree common-port->device->standard
- the spec here is =(host . ((port . device)))=
#+begin_src emacs-lisp :tangle no
'((thinkpad . ((base . eDP-1)
               (usbc . DP-1)
               (hdmi . HDMI-1)))
  (xps . ((base . eDP-1)
          (usbc . DP-1)
          (hdmi . HDMI-1))))
#+end_src

#+RESULTS:
| thinkpad | (base . eDP-1) | (usbc . DP-1) | (hdmi . HDMI-1) |
| xps      | (base . eDP-1) | (usbc . DP-1) | (hdmi . HDMI-1) |

*** ultrawide
#+begin_src emacs-lisp
(require 'exwm-randr)

(defun qz/exwm-usbc-ultrawide ()
  (setq exwm-randr-workspace-monitor-plist '(0 "DP-1"))
  (add-hook
   'exwm-randr-screen-change-hook
   (lambda ()
     (start-process-shell-command
      "xrandr" nil
      "xrandr --output HDMI-2 --off --output HDMI-1 --off --output DP-1 --off --output eDP-1 --off --output DP-1 --primary --mode 5120x1440 --pos 0x0 --rotate normal --output DP-2 --off")))
  (exwm-randr-enable))

(defun qz/exwm-hdmi-ultrawide ()
  (setq exwm-randr-workspace-monitor-plist '(0 "HDMI-1"))
  (add-hook
   'exwm-randr-screen-change-hook
   (lambda ()
     (start-process-shell-command
      "xrandr" nil
      "xrandr --output eDP-1 --off --output DP-1 --off --output HDMI-1 --primary --mode 5120x1440 --pos 0x0 --rotate normal --output DP-2 --off --output HDMI-2 --off")))
  (exwm-randr-enable))
#+end_src

*** tv
#+begin_src emacs-lisp
(defun qz/exwm-hdmi-tv ()
  (setq exwm-randr-workspace-monitor-plist '(0 "HDMI-1"))
  (add-hook
   'exwm-randr-screen-change-hook
   (lambda ()
     (start-process-shell-command
      "xrandr" nil
      "xrandr --output eDP1 --off --output DP1 --off --output DP2 --off --output HDMI1 --primary --mode 1920x1080 --pos 0x0 --rotate normal --scale 2x2 --output HDMI2 --off --output VIRTUAL1 --off")))
  (exwm-randr-enable))
#+end_src

#+RESULTS:
: qz/exwm-hdmi-tv

*** defaults
I've chosen a default res for a laptop of 1920x1080; this is just bearable
enough to debug some bullshit when the world is on fire
#+begin_src emacs-lisp
(defun qz/exwm-standard ()
  (setq exwm-randr-workspace-monitor-plist '(0 "eDP-1"))
  (add-hook
   'exwm-randr-screen-change-hook
   (lambda ()
     (start-process-shell-command
      "xrandr" nil
      "xrandr --output eDP-1 --primary --mode 1920x1080 --pos 0x0 --rotate normal --output DP-1 --off --output HDMI-1 --off --output DP-2 --off")))
  (exwm-randr-enable))
#+end_src
*** devices
#+begin_src emacs-lisp
(defun qz/exwm-thinkpad ()
  (setq exwm-randr-workspace-monitor-plist '(0 "eDP-1"))
  (add-hook
   'exwm-randr-screen-change-hook
   (lambda ()
     (start-process-shell-command
      "xrandr" nil
      "xrandr --output eDP1 --scale .75")))
  (exwm-randr-enable))
#+end_src
*** TODO init; make this work better
system-specific, but would also be nice to have it port-specific, or at least
fall back to standard, respecting font-sizes. whatever.
#+begin_src emacs-lisp
(cond
  ((string-equal system-name "qzdl") (qz/exwm-hdmi-tv))
  ((string-equal system-name "donutrust") (qz/exwm-usbc-ultrawide))
  (t (qz/exwm-standard)))
(exwm-enable)
(exwm-init)
#+end_src
** fixing keys :kbd:
https://github.com/ch11ng/exwm/issues/839#issuecomment-850191548
#+begin_src emacs-lisp
(defun qz/exwm-input--update-global-prefix-keys ()
  "an interactive wrapper to rebind with `exwm-input--update-global-prefix-keys'"
  (interactive)
  (exwm-input--update-global-prefix-keys))

(with-eval-after-load (exwm-input--update-global-prefix-keys))
#+end_src

#+RESULTS:

** TODO gaps (experimental)
#+begin_src emacs-lisp :tangle no
(defvar exwm-gap-monitor 100)

(defun exwm-randr-refresh ()
  "Refresh workspaces according to the updated RandR info."
  (interactive)
  (exwm--log)
  (let* ((result (if exwm-randr--compatibility-mode
                     (exwm-randr--get-outputs)
                   (exwm-randr--get-monitors)))
         (primary-monitor (elt result 0))
         (monitor-geometry-alist (elt result 1))
         (monitor-alias-alist (elt result 2))
         container-monitor-alist container-frame-alist)
    (when (and primary-monitor monitor-geometry-alist)
      (when exwm-workspace--fullscreen-frame-count
        ;; Not all workspaces are fullscreen; reset this counter.
        (setq exwm-workspace--fullscreen-frame-count 0))
      (dotimes (i (exwm-workspace--count))
        (let* ((monitor (plist-get exwm-randr-workspace-monitor-plist i))
               (geometry (cdr (assoc monitor monitor-geometry-alist)))
               (frame (elt exwm-workspace--list i))
               (container (frame-parameter frame 'exwm-container)))
          (if geometry
              ;; Unify monitor names in case it's a mirroring setup.
              (setq monitor (cdr (assoc monitor monitor-alias-alist)))
            ;; Missing monitors fallback to the primary one.
            (setq monitor primary-monitor
                  geometry (cdr (assoc primary-monitor
                                       monitor-geometry-alist))))
          (setq container-monitor-alist (nconc
                                         `((,container . ,(intern monitor)))
                                         container-monitor-alist)
                container-frame-alist (nconc `((,container . ,frame))
                                             container-frame-alist))
          (set-frame-parameter frame 'exwm-randr-monitor monitor)
          (set-frame-parameter
           frame 'exwm-geometry
           (with-slots (x y width height) geometry
             (make-instance 'xcb:RECTANGLE
                            :x (and x (+ x exwm-gap-monitor))
                            :y (and y (+ y exwm-gap-monitor))
                            :width (and width
                                        (- width
                                           (* 2 exwm-gap-monitor)))
                            :height (and height
                                         (- height
                                            (* 2 exwm-gap-monitor))))))))
      ;; Update workareas.
      (exwm-workspace--update-workareas)
      ;; Resize workspace.
      (dolist (f exwm-workspace--list)
        (exwm-workspace--set-fullscreen f))
      (xcb:flush exwm--connection)
      ;; Raise the minibuffer if it's active.
      (when (and (active-minibuffer-window)
                 (exwm-workspace--minibuffer-own-frame-p))
        (exwm-workspace--show-minibuffer))
      ;; Set _NET_DESKTOP_GEOMETRY.
      (exwm-workspace--set-desktop-geometry)
      ;; Update active/inactive workspaces.
      (dolist (w exwm-workspace--list)
        (exwm-workspace--set-active w nil))
      ;; Mark the workspace on the top of each monitor as active.
      (dolist (xwin
               (reverse
                (slot-value (xcb:+request-unchecked+reply exwm--connection
                                (make-instance 'xcb:QueryTree
                                               :window exwm--root))
                            'children)))
        (let ((monitor (cdr (assq xwin container-monitor-alist))))
          (when monitor
            (setq container-monitor-alist
                  (rassq-delete-all monitor container-monitor-alist))
            (exwm-workspace--set-active (cdr (assq xwin container-frame-alist))
                                        t))))
      (xcb:flush exwm--connection)
      (run-hooks 'exwm-randr-refresh-hook))))
#+end_src

#+RESULTS:
: exwm-randr-refresh

** global bindings :kbd:
#+begin_src emacs-lisp
(require 'exwm-input)

(defmacro qz/exwm-bind-keys (&rest bindings)
  "Bind input keys in EXWM.
INDINGS is a list of cons cells containign a key (string) and a command."
  `(progn
     ,@(cl-loop for (key . cmd) in bindings
                collect `(exwm-input-set-key
                          ,(cond ((stringp key) (kbd key))
                                 (t key))
                          (quote ,cmd)))))

(require 'window-go)
(qz/exwm-bind-keys
 ("s-r" .   exwm-reset)                     ;; `s-r': Reset (to line-mode).
 ("s-w" .   exwm-workspace-switch)          ;; `s-w': Switch workspace.
 ("s-&" .   qz/read-process-shell-command)  ;; `s-&': Launch program
 ("s-h" .   windmove-left)                  ;; `HJKL' window navigation
 ("s-j" .   windmove-down)                  ;
 ("s-k" .   windmove-up)                    ;
 ("s-l" .   windmove-right)                 ;
 ("s-n" .   switch-to-next-buffer)          ;; cycle buffer stack in window
 ("s-p" .   switch-to-prev-buffer)          ;      (n)ext   (p)revious
 ("s-0" .   sticky-window-delete-window)    ;;     rebound `C-x 0' windowcmd
 ("s-+" .   sticky-window-delete-other-windows) ;; rebound `C-x 1` windowcmd
 ("s-b" .   qz/exwm-goto-browser)           ;; GOTO: browser, current window
 ("C-s-b" . qz/goto-the-sticky-window)
 ("s-a" .   qz/org-agenda-gtd))
#+end_src

#+RESULTS:

** goto :func:
#+begin_src emacs-lisp
(defun exwm-goto--switch-to-buffer (buf)
  (if-let ((w (get-buffer-window buf t)))
      (select-window w)
    (exwm-workspace-switch-to-buffer buf)))

(cl-defun exwm-goto (command &key class)
  (if-let ((bs (cl-remove-if-not (lambda (buf)
                                   (with-current-buffer buf
                                     (and (eq major-mode 'exwm-mode)
                                          (cond
                                           ((stringp class)
                                            (string-match class exwm-class-name))))))
                                 (buffer-list))))
      (exwm-goto--switch-to-buffer (car bs))
    (start-process-shell-command class nil command)))
#+end_src

#+RESULTS:
: exwm-goto

** TODO goto apps :func:
this doesn't work on my XPS

#+begin_src emacs-lisp
(defun qz/exwm-goto-browser ()
  (interactive)
  (exwm-goto "firefox" :class "Firefox"))
#+end_src

#+RESULTS:
: qz/exwm-goto-browser

** minibuffer :vars:
#+begin_src emacs-lisp
;(setq exwm-workspace-minibuffer-position 'top)
#+end_src

#+RESULTS:

** remove menu & dialog :vars:
#+begin_src emacs-lisp
(menu-bar-mode -1)
(setq mouse-autoselect-window t
      use-dialog-box nil)
#+end_src

#+RESULTS:
** TODO screenshotting with selection / window from dmenu script :func:
** shell command readline :func:
#+begin_src emacs-lisp
(defun qz/read-process-shell-command (command)
  "Used to launch a program by creating a process. Invokes
start-process-shell-command' with COMMAND"
  (interactive (list (read-shell-command "Î» ")))
  (start-process-shell-command command nil command))
#+end_src

#+RESULTS:
: qz/read-process-shell-command

** simulation keys :kbd:
#+begin_src emacs-lisp
(defvar qz/default-simulation-keys
  '(;; movement
    ([?\C-b] . left)
    ([?\M-b] . C-left)
    ([?\C-f] . right)
    ([?\M-f] . C-right)
    ([?\C-p] . up)
    ([?\C-n] . down)
    ([?\C-a] . home)
    ([?\C-e] . end)
    ([?\M-v] . prior)
    ([?\C-v] . next)
    ([?\C-d] . delete)
    ([?\C-k] . (S-end delete))
    ([?\M-d] . (C-S-right delete))
    ;; cut/paste.
    ([?\C-w] . ?\C-x)
    ([?\M-w] . ?\C-c)
    ([?\C-y] . ?\C-v)
    ;; search
    ([?\C-s] . ?\C-f)))

(with-eval-after-load 'exwm-input
  (exwm-input-set-simulation-keys qz/default-simulation-keys))
#+end_src

#+RESULTS:

+RESULTS:
** TODO startup programs :init:
#+begin_src emacs-lisp
(setq qz/startup-programs
      '("compton"
        "unclutter"))

(defun qz/run-programs-n-process (p)
  (mapcar (lambda (c) (start-process-shell-command c nil c)) p))

(defun qz/seq-to-kill (p)
  (mapcar (lambda (s) (concat "killall " s)) p))

(defun qz/run-startup-programs ()
  (interactive)
  (qz/run-programs-n-process
   (qz/seq-to-kill qz/startup-programs))
  (qz/run-programs-n-process qz/startup-programs))

(qz/run-startup-programs)
#+end_src

#+RESULTS:
| compton | unclutter |

** title as buffer naming hook :func:
suspicious; acts as soon as eval'd
#+begin_src emacs-lisp
(add-hook 'exwm-update-title-hook
          (lambda () (exwm-workspace-rename-buffer exwm-title)))
#+end_src

#+RESULTS:
| lambda | nil | (exwm-workspace-rename-buffer exwm-title) |

** wallpaper :init:
<link-to-elisp-doc 'wallpaper-cycle-interval> is measured in seconds, 900 being 15 minutes
#+begin_src emacs-lisp
(setq wallpaper-cycle-interval 900)

(use-package! wallpaper
  :hook ((exwm-randr-screen-change . wallpaper-set-wallpaper)
         (after-init . wallpaper-cycle-mode))
  :custom ((wallpaper-cycle-interval 900)
           (wallpaper-cycle-single t)
           (wallpaper-scaling 'fill)
           (wallpaper-cycle-directory "~/.config/wallpapers")))
#+end_src

#+RESULTS:
| wallpaper-cycle-mode | doom-modeline-mode | doom-init-fonts-h | doom-init-theme-h | doom-init-leader-keys-h | general-auto-unbind-keys | x-wm-set-size-hint | tramp-register-archive-file-name-handler | magit-maybe-define-global-key-bindings |

** windows; window dividers :vars:
#+begin_src emacs-lisp
(setq window-divider-default-right-width 4)
(setq window-divider-default-bottom-width 4)
(window-divider-mode 1)
#+end_src

#+RESULTS:
: t

** windows; automatically float windows :func:
#+begin_src emacs-lisp
(defcustom qz/exwm-floating-window-classes '("keybase" "mpv")
  "List of instance names of windows that should start in the floating mode.")

(defun qz/exwm-float-window-on-specific-windows ()
  (when (member exwm-instance-name qz/exwm-floating-window-classes)
    (exwm-floating-toggle-floating)))
(add-hook 'exwm-manage-finish-hook #'qz/exwm-float-window-on-specific-windows)
#+end_src

#+RESULTS:
| qz/exwm-float-window-on-specific-windows |

** windows; mark windows as real :func:
Emacs can recognise x-windows as 'real' per <link-to-elisp-doc 'doom-real-buffer-p>

#+begin_src emacs-lisp
(add-hook 'exwm-mode-hook #'doom-mark-buffer-as-real-h)
(add-hook 'doom-switch-window-hook #'doom-mark-buffer-as-real-h)

(defun qz/mark-this-buffer-as-real ()
  (interactive)
  (doom-mark-buffer-as-real-h))
#+end_src

#+RESULTS:
: qz/mark-this-buffer-as-real
** windows; sticky windows
:PROPERTIES:
:ID:       0f9dc414-3044-47eb-983a-9804d729d3a4
:END:
:: [[https://www.emacswiki.org/emacs/StickyWindows][EmacsWiki: Sticky Windows]]

#+begin_src emacs-lisp
(defun qz/window-is-sticky? ()
  (interactive)
  (message "is window sticky? %s"(window-dedicated-p)))

(map!
 "C-x 0" 'sticky-window-delete-window
 "C-x 1" 'sticky-window-delete-other-windows)
#+end_src

#+RESULTS:
: qz/window-is-sticky\?

*** sticky-windows.el :file:
:: https://www.emacswiki.org/emacs/sticky-windows.el
#+begin_src emacs-lisp :tangle sticky-windows.el
;;; sticky-windows.el --- Make windows stay visible
;;;
;;; Commentary:
;;;
;;; `sticky-window-keep-window-visible' function marks a specific window as being dedicated with `set-window-dedicated-p'.
;;; However, that does not prevent that window from being deleted with `delete-window' or `delete-other-windows'.  Below are
;;; wrappers for `delete-window' and `delete-other-windows' that respect the "dedicated window" state, and are typically to be
;;; bound to the same keybindings as they are by default in Emacs as follows:
;;;
;;; (global-set-key     [(control x) (?0)]        'sticky-window-delete-window)
;;; (global-set-key     [(control x) (?1)]        'sticky-window-delete-other-windows)
;;;
;;; In addition, `sticky-window-keep-window-visible' might be bound to the currently unused C-x 9 key binding:
;;;
;;; (global-set-key     [(control x) (?9)]        'sticky-window-keep-window-visible)
;;;
;;; Change Log: (optional)

;;;###autoload
(defun sticky-window-keep-window-visible ()
  "Ensure the buffer associated with the current window stays visible.
This is handy for ERC buffers where you would like to see the
conversation while you work in other windows within the frame.
This is intended to be used with `sticky-window-delete-window'.
A prefix arg reverses this operation."
  (interactive)
  (set-window-dedicated-p (selected-window) (not current-prefix-arg)))

;;;###autoload
(defun sticky-window-delete-window (force)
  "This is intended to be a replacement for `delete-window', but
that avoids deleting windows that have been marked as dedicated
with `sticky-window-keep-window-visible'."
  (interactive "P")
  (if force
      (delete-window window)
    (let ((window (selected-window)))
      (if (and (not current-prefix-arg) (window-dedicated-p window))
	  (error "This is a dedicated window. Use C-u prefix on this keybinding to really delete it.")
	(set-window-dedicated-p (selected-window) nil)
	(delete-window window)))))

;;;###autoload
(defun sticky-window-delete-other-windows (force)
  "Delete all other windows that are not marked to be visible with `sticky-window-keep-window-visible'."
  (interactive "P")
  (if force
      (delete-other-windows)
    (mapcar (lambda (window)
	      (if (not (window-dedicated-p window))
		  (delete-window window)))
	    (cdr (window-list)))))

(provide 'sticky-windows)

;;; sticky-windows.el ends here
#+end_src

#+RESULTS:
: sticky-windows
** windows; sticky daily buffer
:: [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Window-Sizes.html]]
it is desirable to have my current overview at hand so I'm not getting
distracted.

goals:
- keep in view with [[0f9dc414-3044-47eb-983a-9804d729d3a4][windows; sticky-windows]]
- a useable fixed size; min/max width bounds on size at 80char
- no vertical splits; this one might be tough
- 'permenant' enough to avoid accidental killing, but able to change with
  ibuffer if necessary (prioritise clocked task)
- hot-binding to switch, like the canonical repl back+forth with {C-c C-z}
- goes away in zen-mode


*** sticky properties :vars:
#+begin_src emacs-lisp
(defvar qz/the-sticky-window nil)
(defvar qz/last-before-sticky-window nil)
(defvar qz/sticky-buffer-width 90)
#+end_src

#+RESULTS:
: qz/sticky-buffer-width

*** make-window-sticky :func:
#+begin_src emacs-lisp
(defun qz/make-window-sticky (&optional window)
  (interactive)
  (message
   "stickied window %s"
   (setq qz/the-sticky-window
         (let* ((w (or window (selected-window)))
                (ww (- qz/sticky-buffer-width (window-width w))))
           (when (and (> 0 window-resizable w ww)
                      (window-resize w ww t))
             (window-preserve-size w t t))
           (sticky-window-keep-window-visible)
           w)))
  qz/the-sticky-window)
;(qz/make-window-sticky)


#+end_src

#+RESULTS:

*** goto-the-sticky-window :func:
#+begin_src emacs-lisp
(defun qz/goto-the-sticky-window (&optional returning-window)
  (interactive)
  (let ((w (or returning-window (selected-window))))
    (if (not (equal w qz/the-sticky-window))
      (progn (setq qz/last-before-sticky-window w)
             (select-window qz/the-sticky-window))
      (select-window (or qz/last-before-sticky-window w)))))
#+end_src

#+RESULTS:
***
*** sticky-candidates and selection
where a candidate is a function that returns a buffer.

- might be interesting to permit interop with perspective.el, where the 'sticky'
  is an interface to a persp workspace. bit overkill for now though
  - (+workspace-buffer-list)
  - (+ivy/switch-workspace-buffer)

#+begin_src emacs-lisp
(defvar qz/org-roam-dailies-filespec-HACK
  "private-%Y-%m-%d.org"
  "see `qz/org-roam-dailies-filespec' for the org-template variant")

(defun qz/get-daily-file-as-buffer ()
  "Returns a `buffer' for the `dailies-file' according to
  `qz/org-roam-dailies-filespec-HACK', of directory
  `org-roam-dailies-path'.

- if the file exists, use `find-file-noselect' to pop a
  buffer (fast path)
- if the file doesn't exist, use `org-roam-dailies-' creation via
  `org-capture'

it was a pain to deal with the fallout of `org-capture'
window/buffer handling (no **background** buffer operations!!!!).

the solution found for this `org-capture' path is incompatible
with the `find-file-noselect' path, which operates on the same
window throughout the operation, hence the distinction given by
local `exists?'."
  (interactive)
  (let* (target
         (current-buf (current-buffer))
         (maybe-daily-file
          (concat org-roam-dailies-directory
                  (format-time-string qz/org-roam-dailies-filespec-HACK))))
    (with-current-buffer (generate-new-buffer " *sticky-internal*")
      (let* ((exists?
              (and (file-exists-p maybe-daily-file)
                   (find-file-noselect maybe-daily-file)))
             (target
              (or exists?
                  (progn
                    (call-interactively 'org-roam-dailies-goto-today)
                    (current-buffer)))))
        (if exists?
            ;; path: find-file-noselect
            (and nil (set-buffer current-buf) exists?)
            ;; path: org-capture external window hijacking workaround
          (mapcar (lambda (w) (quit-window nil w))
                  (get-buffer-window-list target)))
        target))))

(setq qz/sticky-buffer-candidate-alist
  '((daily . qz/get-daily-file-as-buffer)
    (clocked . (lambda () "TODO"))
    (chopi . (lambda () "hi chopi"))))

(defun qz/sticky-buffer-candidates ()
  "get the names from `qz/sticky-buffer-candidate-alist'"
  (mapcar 'car qz/sticky-buffer-candidate-alist))

(defun qz/choose-candidate (prompt namelist alist)
  (when-let ((can (completing-read prompt namelist)))
    (funcall (cdr (assoc (intern can) alist)))))

(defun qz/sticky-choose-candidate ()
  (qz/choose-candidate
   "choose a buffer to sticky: "
   (qz/sticky-buffer-candidates)
   qz/sticky-buffer-candidate-alist))

;(qz/sticky-buffer-candidates)
;(qz/get-daily-file-as-buffer)
;(qz/sticky-choose-candidate)
#+end_src

#+RESULTS:
: qz/sticky-choose-candidate

*** TODO expand org-escape from capture templates
extract the 'escape' format as used in org-capture templates. really more
trouble than it's worth, but if I see it through, would be a valid PR for org
mainline.

see <link-to-elisp-doc 'org-capture-fill-template>

*** sticky-setup-window
#+begin_src emacs-lisp
(defun qz/sticky-setup-window (&optional window buffer)
  "use `C-u' prefix-arg to sticky current"
  (interactive)
  (destructuring-bind (buffer window)
      (or (and current-prefix-arg
               (list (current-buffer) (selected-window)))
          (list (buffer window)))
    (set-window-buffer window buffer nil)
    (qz/make-window-sticky window)))

#+end_src

#+RESULTS:
: qz/sticky-setup-window

** windows; send/copy to MAIN window
to save my fucking neck in 5120x1440 exwm man

** workspaces & classes :vars:
#+begin_src emacs-lisp
;; Set the initial workspace number.
(unless (get 'exwm-workspace-number 'saved-value)
  (setq exwm-workspace-number 4))

;; Make class name the buffer name
(add-hook 'exwm-update-class-hook
          (lambda () (exwm-workspace-rename-buffer exwm-class-name)))
#+end_src

#+RESULTS:
| lambda | nil | (exwm-workspace-rename-buffer exwm-class-name) |


* nano
#+begin_src emacs-lisp
(require 'nano-layout)
(require 'nano-theme-dark)

;; Theme
(require 'nano-faces)
(nano-faces)

(require 'nano-theme)
(nano-theme)

;; Nano default settings (optional)
;; (require 'nano-defaults)

;; Nano session saving (optional)
;(require 'nano-session)

;; Nano header & mode lines (optional)
(require 'nano-modeline)

;; Nano key bindings modification (optional)
;;(require 'nano-bindings)

;; Compact layout (need to be loaded after nano-modeline)
;(require 'nano-compact)

;; Nano counsel configuration (optional)
;; Needs "counsel" package to be installed (M-x: package-install)
(require 'nano-counsel)

;; Help (optional)
(require 'nano-help)
#+end_src

#+RESULTS:
: nano-help
* visual
** fonts & text :vars:

#+begin_src emacs-lisp
(setq doom-font (font-spec :family "monospace" :size qz/font-default))
(setq doom-theme nil)
(setq doom-modeline-height 10)
(setq display-line-numbers-type nil)
(set-language-environment "UTF-8")
(set-default-coding-systems 'utf-8)
#+end_src

#+RESULTS:
: (utf-8-unix . utf-8-unix)

** use tooltips :init:
#+begin_src emacs-lisp
(tooltip-mode 1)
#+end_src

#+RESULTS:
: t

** toggling time in the modeline :kbd:
An example of this can be found in [[Time in the modeline]]. Equal is used here to
coerce non-numeric arguments into something that will toggle.
#+begin_src emacs-lisp
(setq qz/toggle-time-state t)
(display-time-mode qz/toggle-time-state)

(defun qz/toggle-time-in-modeline ()
  (interactive)
  (message
   (concat "Time display in modeline is "
           (if (display-time-mode
                (setq qz/toggle-time-state
                      (qz/toggle-1->0 qz/toggle-time-state)))
               "on" "off"))))

(map! :leader
      (:prefix-map ("t" . "toggle")
       :desc "Time in the modeline"   "T" #'qz/toggle-time-in-modeline))
#+end_src

#+RESULTS:
: qz/toggle-time-in-modeline

** kill default menu/tool/scroll-bar
#+begin_src emacs-lisp
(tool-bar-mode -1)
(scroll-bar-mode -1)
(menu-bar-mode -1)
#+end_src
** writeroom settings :vars:

#+begin_src emacs-lisp
(setq writeroom-width 80)

(add-to-list 'writeroom-mode-hook
             (lambda () (setq writeroom-border-width 50)))
#+end_src

#+RESULTS:
| (lambda nil (setq writeroom-border-width 50)) | +zen-enable-mixed-pitch-mode-h |

** theme :func:
#+begin_src emacs-lisp
(defun qz/load-tron-legacy ()
  (interactive)
  (add-to-list 'custom-theme-load-path "~/.emacs.d/.local/straight/repos/tron-legacy-emacs-theme/")
  (load-theme 'tron-legacy t)
  (setq tron-legacy-vivid-cursor t))

(defun qz/load-k ()
  (interactive)
  (load-theme 'k t))

(defun qz/load-pink-mountain ()
  (interactive)
  (load-theme 'pink-mountain t))

;; cba
;(load-theme 'modus-vivendi t)
#+end_src

#+RESULTS:
: qz/load-pink-mountain

** TODO [[id:956fe315-004c-49e6-958c-c4791eb83357][ivy-posframe]] :init:
[[https://github.com/tumashu/ivy-posframe][GitHub - tumashu/ivy-posframe: ivy-posframe is a ivy extension, which let ivy...]]

this fucking sucks with [[id:2c8c6541-74a2-4e13-af5b-b463a429937d][EXWM]], just jumps about the place with each poll of the window

#+begin_src emacs-lisp
;(require 'ivy-posframe)
;
;(defun sarg/ivy-posframe-poshandler (info)
;  (setq-local
;   workarea (elt exwm-workspace--workareas exwm-workspace-current-index)
;   return-value (posframe-poshandler-frame-center info)
;    (cons (+ (aref workarea 0) (car return-value))
;          (+ (aref workarea 1) (cdr return-value))))
;  return-value)
;
;(defun sarg/ivy-posframe-exwm (str)
;  (ivy-posframe--display str #'sarg/ivy-posframe-poshandler))
;
;(after! ivy-posframe
;  (setq ivy-posframe-display-functions-alist '((t . sarg/ivy-posframe-exwm))
;        ivy-posframe-border-width 4
;        ivy-posframe-parameters '((parent-frame nil))))
;
;(ivy-posframe-mode 1)
#+end_src

#+RESULTS:

** transparency :func:
totally stolen from [[https://www.emacswiki.org/emacs/TransparentEmacs][EmacsWiki: Transparent Emacs]].

remember to flick on compton to complete the rice
#+begin_src emacs-lisp
(setq qz/preferred-transparency-alpha '(80 . 70))

(set-frame-parameter (selected-frame) 'alpha qz/preferred-transparency-alpha)
(add-to-list 'default-frame-alist `(alpha . ,qz/preferred-transparency-alpha))

(defun qz/toggle-transparency ()
  "Toggle between max opacity and `qz/preferred-transparency-alpha'"
  (interactive)
  (let ((alpha (frame-parameter nil 'alpha)))
    (set-frame-parameter
     nil 'alpha
     (if (eql (cond ((numberp alpha) alpha)
                    ((numberp (cdr alpha)) (cdr alpha))
                    ;; Also handle undocumented (<active> <inactive>) form.
                    ((numberp (cadr alpha)) (cadr alpha)))
              100)
         qz/preferred-transparency-alpha '(100 . 100))))
  (message (concat "Frame transparency set to "
                   (number-to-string (car (frame-parameter nil 'alpha))))))
#+end_src

#+RESULTS:
: qz/toggle-transparency

** [[id:cdc9ba5e-137a-4a28-82ab-2b4c53e5b087][bgex]] :init:
a patched build of emacs, for crazy bitmap ricing. I found this on r/unixporn

To create a source image, run ~convert a.png a.xpm~


#+begin_src emacs-lisp :tangle no
;(load-file "~/.doom.d/snippets/bgex.el")
;(require 'bgex)

;; Image on frame (dynamic color mode (SRC * DST / factor))
;; (bgex-set-image-default "~/.config/wall.xpm" t)
;; Color for HTML-mode (dynamic color mode)
;; (bgex-set-color "HTML" 'bgex-identifier-type-major-mode '(60000 40000 40000) t)

;; ;; Color for buffer-name (*scratch*)
;; (bgex-set-color "*scratch*" 'bgex-identifier-type-buffer-name "skyblue")
;; (bgex-set-color-default "skyblue")
;; ;; XPM string
;; (bgex-set-xpm-string "*scratch*" 'bgex-identifier-type-buffer-name "XPM string" t)
;; (bgex-set-xpm-string-default "XPM strging" t)
#+end_src

#+RESULTS:
** [[id:c6490b3a-4dc3-4f9a-bb21-81bb6abc6beb][perfect-margin]] :init:
the absolute GOAT for ultrawide monitors. {C-x 1} is your friend
#+begin_src emacs-lisp
(perfect-margin-mode 1)
(setq perfect-margin-ignore-regexps nil
      perfect-margin-ignore-filters nil)
#+end_src

#+RESULTS:
*** hacky-margin; minibuffer centering
#+begin_src emacs-lisp
(defun qz/set-message-filter ()
  (interactive)
  (defun message-filter-center (args)
    "Center message string.
  This is a :filter-args advice for `message`."
    (set-window-margins (minibuffer-window) 0)
    (set-window-margins
     (minibuffer-window)
     (if (not (car args))
         (/ 2 (frame-width)) ;; a new 'default' echo position
       (max 0 (/ (- (window-width (minibuffer-window))
                    (string-width (car args)))
                 2))))
    args)) ;; allow regular args to be passed

(defun qz/reset-message-filter ()
  (interactive)
  (defun message-filter-center (args) args))

(advice-add #'message :filter-args #'message-filter-center)
(qz/set-message-filter)
#+end_src

#+RESULTS:
: message-filter-center


#+begin_src emacs-lisp
;; Anselm
#+end_src

#+RESULTS:
: message-filter-center

* TODO hydra
** n :kbd:
The =n= of {C-c n} denotes notes.

#+begin_src emacs-lisp
(map! :leader
      (:prefix-map ("n" . "notes")
       (:prefix-map ("d" . "by date")
          :desc "Arbitrary date" "d" #'org-roam-dailies-date
          :desc "Today"          "t" #'org-roam-dailies-today
          :desc "Tomorrow"       "m" #'org-roam-dailies-tomorrow
          :desc "Yesterday"      "y" #'org-roam-dailies-yesterday)
       "C-c" #'org-capture
       "F" #'find-file-in-notes))
#+end_src

#+RESULTS:
: find-file-in-notes
** TODO {s-o} tasks, clocking
#+begin_src emacs-lisp :tangle no
(map! :leader
      (:prefix-map ("C-o" . "org-tasks")
         :desc "clock-in"  "i" #'org-clock-in-current
         :desc "clock-out" "o" #'org-clock-in-current
         :desc "select clock" "s-o" #'org-clock-in-current
         :desc "goto clock"   "s-n" #'org-clock-in-current
         ))


#+end_src

#+RESULTS:
: org-clock-in-current
* [[id:5f896cd4-d7b8-44d2-a40d-ccdae1b80c33][programming]]
** [[id:eae3ee00-be74-4f59-8a4d-b638baebc9f8][SQL]]
For reference: [[https://www.emacswiki.org/emacs/SqlMode][EmacsWiki: Sql Mode]]
*** Toggle ERROR_ROLLBACK :psql:func:
#+begin_src emacs-lisp
(setq qz/psql-error-rollback 0)

(qz/toggle-1->0 qz/psql-error-rollback)

(defun qz/psql-toggle-error-rollback ()
  (interactive)
  (setq qz/psql-error-rollback
        (qz/toggle-1->0 qz/psql-error-rollback))
  (sql-send-string
   (concat "\\set ON_ERROR_ROLLBACK "
           (qz/toggle-on->off qz/psql-error-rollback)))
  (sql-send-string
   "\\echo ON_ERROR_ROLLBACK is :ON_ERROR_ROLLBACK"))
#+end_src

#+RESULTS:
: qz/psql-toggle-error-rollback

*** Upcase SQL Keywords :func:
Lifted from [[https://www.emacswiki.org/emacs/SqlMode#toc4][EmacsWiki: Sql Mode]] (#toc4)
#+begin_src emacs-lisp
  (defun qz/upcase-sql-keywords ()
    (interactive)
    (save-excursion
      (dolist (keywords sql-mode-postgres-font-lock-keywords)
        (goto-char (point-min))
        (while (re-search-forward (car keywords) nil t)
          (goto-char (+ 1 (match-beginning 0)))
          (when (eql font-lock-keyword-face (face-at-point))
            (backward-char)
            (upcase-word 1)
            (forward-char))))))
#+end_src

#+RESULTS:
: qz/upcase-sql-keywords
*** sqlite binary
#+begin_src emacs-lisp
(setq sql-sqlite-program "sqlite3")
(setq emacsql-sqlite-executable "~/.guix-profile/bin/emacsql-sqlite")
#+end_src

#+RESULTS:
: ~/.guix-profile/bin/emacsql-sqlite
** python
*** elpy :init:
#+begin_src emacs-lisp
(require 'elpy)
(elpy-enable)
(setq elpy-rpc-python-command "python3")
#+end_src

#+RESULTS:
: python3
*** binds
#+begin_src emacs-lisp
(map! :mode python-mode
   "M-." #'elpy-goto-definition-other-window)
#+end_src

#+RESULTS:

** paredit ([[id:2c3dfd8a-9a85-4531-842f-e688235f4136][lisp]])
*** paredit-forward/backward-slurp {M-n/p} :kbd:
so useful it's unreal
#+begin_src emacs-lisp
(map! :mode paredit-mode
      "M-p" #'paredit-forward-slurp-sexp
      "M-n" #'paredit-backward-slurp-sexp)
#+end_src

#+RESULTS:

** [[id:5ea2fb1b-3638-41ea-94e2-9da57f5cacbc][common lisp]]
*** cl-font-lock-built-in-mode :vars:
"Highlight built-in functions, variables, and types in âlisp-modeâ."
- Enable feature from 28.1 if exists
  <link-to-elisp-doc 'cl-font-lock-built-in-mode>
#+begin_src emacs-lisp :tangle no
(if (symbolp 'cl-font-lock-built-in-mode)
    (cl-font-lock-built-in-mode 1))
#+end_src

#+RESULTS:
: t
*** sly, from roswell
yep, just ~ros install sly~
#+begin_src emacs-lisp
(let ((f (expand-file-name "~/.roswell/helper.el")))
  (when (file-exists-p f)
      (load f)))
#+end_src

*** TODO sly eval-overlay :func:
this doesn't actually work. kinda jealous of CIDER ngl

Using the handy [[https://github.com/xiongtx/eros][eros]], advice from [[https://www.reddit.com/r/emacs/comments/bi4xk1/evaluation_overlays_in_slime_for_common_lisp/][Evaluation overlays in slime for common lisp : emacs]]
#+begin_src emacs-lisp :tangle no
(autoload 'cider--make-result-overlay "cider-overlays")

(defun endless/eval-overlay (value point)
  (cider--make-result-overlay (format "%S" value)
                              :where point
                              :duration 'command)
  ;; Preserve the return value.
  value)


;; (define-key! 'sly-mode-map "C-x C-e" 'sly-eval-last-expression)
#+end_src

#+RESULTS:
: endless/eval-overlay

** [[id:4ce144c6-7264-4936-8cc5-a3b33be8be00][emacs lisp]]
*** eval-defun :kbd:
yep, [[id:c20edb0c-16a1-4b6a-ac73-8b98782740cd][SLIME]] conventions please
#+begin_src emacs-lisp
(define-key! emacs-lisp-mode-map "C-c C-c" 'eval-defun)
#+end_src

#+RESULTS:
** scheme
#+begin_src emacs-lisp
(defvar geiser-scheme-implementation 'guile)
#+end_src

#+RESULTS:
: geiser-scheme-implementation

** eshell
*** sudo, password caching :vars:
#+begin_src emacs-lisp
(require 'em-tramp)
(setq eshell-prefer-lisp-functions nil
      eshell-prefer-lisp-variables t
      password-cache t
      password-cache-expiry 300)

#+end_src

#+RESULTS:
: 300
**

* [[id:d342065d-2042-4e8b-938d-ed121debc179][hyperbole]]
** Initialisation :init:#+begin_src emacs-lisp
(require 'hyperbole)
#+end_src

#+RESULTS:
: hyperbole

** Action-Key with mouse buttons :kbd:
#+begin_src emacs-lisp
(map! "C-<mouse-2>" #'hkey-either)
#+end_src

#+RESULTS:

* PDF
** Dark-Mode on entry :vars:
This function takes colours from the current [[Theme]], and applies a colour-mask to
the view of the pdf as it's rendered by PDFTools.
#+begin_src emacs-lisp
(add-hook 'pdf-view-mode-hook #'pdf-view-midnight-minor-mode)
#+end_src

#+RESULTS:
| (closure (t) (&rest _) (add-hook 'kill-buffer-hook #'+pdf-cleanup-windows-h nil t)) | doom--setq-evil-normal-state-cursor-for-pdf-view-mode-h | pdf-tools-enable-minor-modes | doom-modeline-set-pdf-modeline | pdf-view-midnight-minor-mode |
** mouse precise note insert {C-<mouse-1>}
also, for mouse fuckery, see [[mouse button fuckery]]
#+begin_src emacs-lisp
(defun qz/noter-create-precise ()
  (interactive)
  (org-noter-insert-note (qz/get-precise)))


(defun qz/noter-create-precise-buffer-popup ()
  (interactive)
  (setq qz/org-noter-buffer (current-buffer)
        qz/precise-pos (qz/get-precise)
        qz/buffer-popup-final
        (lambda ()
          (message "yeet")
          (with-current-buffer qz/org-noter-buffer
            (qz/org-noter-insert-note qz/buffer-popup-last-value
                                      qz/precise-pos))))
  (qz/buffer-popup-create))

(defun qz/get-precise ()
  (interactive)
  (let ((v   (org-noter--conv-page-scroll-percentage
      (+ (window-vscroll)
         (qz/thing-at-point))))
)
(message "%s" v)
v))


(map! :mode pdf-sync-minor-mode
      "C-<mouse-1>" #'qz/noter-create-precise-buffer-popup)
(map!
      "C-<mouse-1>" #'qz/noter-create-precise-buffer-popup)
#+end_src
** highlight region in pdf with {h}
#+begin_src emacs-lisp
(map! :mode pdf-view-mode
      "h" #'pdf-annot-add-highlight-markup-annotation)
#+end_src

* [[id:68ebe469-0a04-4a0c-ba46-0efc9a868351][KeyFreq]] :init:
A package that logs command usage; blessed be Xah Lee
#+begin_src emacs-lisp
(keyfreq-mode 1)
(keyfreq-autosave-mode 1)
#+end_src

#+RESULTS:
: t

* org
** [[file:../../../life/roam/20200515T120103Z-org_mode.org][org-mode]] :init:vars:
#+begin_src emacs-lisp :results none
(use-package! org
  :mode ("\\.org\\'" . org-mode)
  :init
  (map! :map org-mode-map
        "M-n" #'outline-next-visible-heading
        "M-p" #'outline-previous-visible-heading
        "C->" #'org-do-demote
        "C-<" #'org-do-promote)
  (setq org-src-window-setup 'current-window
        org-return-follows-link t
        org-babel-load-languages '((emacs-lisp . t)
                                   (lisp . t)
                                   (jupyter . t)
                                   (python . t)
                                   (ipython . t)
                                   (scheme . t)
                                   (R . t))
        org-ellipsis " â¼ "
        org-confirm-babel-evaluate nil
        org-use-speed-commands t
        org-catch-invisible-edits 'show
        org-preview-latex-image-directory "/tmp/ltximg/"
        ;; ORG SRC BLOCKS {C-c C-,}
        org-structure-template-alist '(("q" . "quote")
                                       ("d" . "definition")
                                       ("s" . "src")
                                       ("ss" . "src scheme")
                                       ("sb" . "src bash")
                                       ("se" . "src emacs-lisp")
                                       ("sp" . "src psql")
                                       ("jp" . "src    jupyter-python")
                                       ("jr" . "src jupyter-R")
                                       ("sr" . "src R")
                                       ("el" . "src emacs-lisp")))
  (with-eval-after-load 'flycheck
    (flycheck-add-mode 'proselint 'org-mode)))
#+end_src

** org-id :init:vars:
#+begin_src emacs-lisp
(require 'org-id)
(setq org-id-track-globally t)
#+end_src

#+RESULTS:
: t

** tweaks :vars:
*** File apps
Handle opening with { C-c C-o } or { RET } or { mouse-1 }
- <link-to-elisp-doc 'org-file-apps>

#+begin_src emacs-lisp
(setq org-file-apps
      '((auto-mode . emacs)
        (directory . emacs)
        ("\\.mm\\'" . default)
        ("\\.x?html?\\'" . default)
        ("\\.pdf\\'" . emacs)))
#+end_src

#+RESULTS:
: ((auto-mode . emacs) (directory . emacs) (\.mm\' . default) (\.x?html?\' . default) (\.pdf\' . emacs))

*** Cleanup ~org-mode-hook~
#+begin_src emacs-lisp
(eval-after-load nil
  (remove-hook 'org-mode-hook #'ob-ipython-auto-configure-kernels))
#+end_src

#+RESULTS:
*** Strikethough DONE headings
#+begin_src emacs-lisp
(if (boundp 'org-headline-done) (set-face-attribute 'org-headline-done nil :strike-through t))
#+end_src

#+RESULTS:

**** DONE YEAH BOY HAHAHAHAHAHAHAAHAHAHAHAHAHAHAHAHAHAHAHAHAHA
*** auto insert headings that match radio text + tagging
#+begin_src emacs-lisp
(defun qz/definer-headliner (s) "civiliser 85er" (concat "<<<.*-" s ">>>.*:" s ":"))

(defun qz/get-radio-naked (r)
  (car (split-string (cadr (split-string r "<<<")) ">>>")))

;;(qz/get-radio-naked "<<<data>>>")

(defun qz/insert-radio-children ()
  "fucking awesome"
  (interactive)
  (org-with-wide-buffer
   (org-back-to-heading t)
   (let* ((case-fold-search nil)
          (pt (point)))
     (when (looking-at org-complex-heading-regexp)
       (let ((relate (qz/get-radio-naked (match-string-no-properties 4))))
         (message "relating: %s" relate)
         (mapc (lambda (s) (save-excursion (message "inserting subheading %s" s) (org-insert-subheading nil) (insert s) s))
               (mapcar #'qz/get-radio-naked
                       (qz/matches-in-buffer (message (qz/definer-headliner relate))))))))))

;; (defun qz/matches-in-buffer (regexp &optional buffer with-point?)
;;   "return a list of matches of REGEXP in BUFFER or the current buffer if not given."
;;   (let ((matches))
;;     (save-match-data
;;       (save-excursion
;;         (with-current-buffer (or buffer (current-buffer))
;;           (save-restriction
;;             (widen)
;;             (goto-char 1)
;;             (while (search-forward-regexp regexp nil t 1)
;;               (let ((s (match-string-no-properties 0))
;;                     (push (if with-point? (cons s (point)) s) matches)))))))
;;       matches)))

;; (defun qz/matches-in-buffer (regexp &optional buffer with-point)
;;   "return a list of matches of REGEXP in BUFFER or the current buffer if not given."
;;   (let ((matches nil))
;;     (save-match-data
;;       (save-excursion
;;         (with-current-buffer (or buffer (current-buffer))
;;           (save-restriction
;;             (widen)
;;             (goto-char 1)
;;             (while (search-forward-regexp regexp nil t 1)
;;               (let ((s (match-string-no-properties 0)))
;;                 (push (if with-point (cons s (point)) s) matches)))))))
;;     matches))
#+end_src

#+RESULTS:
: qz/insert-radio-children

** directories :vars:
#+begin_src emacs-lisp
(setq org-directory "~/life/"
      qz/notes-directory (concat org-directory "roam/")
      qz/org-agenda-directory qz/notes-directory
      qz/org-agenda-files (mapcar (lambda (f) (expand-file-name (concat qz/notes-directory f)))
                                  '("calendar-home.org" "calendar-work.org" "schedule.org"))
      org-ref-notes-directory qz/notes-directory
      bibtex-completion-notes-path qz/notes-directory
      org-ref-bibliography-notes "~/life/bib.org"
      org-noter-notes-search-path (list qz/notes-directory)
      org-roam-directory qz/notes-directory
      org-roam-dailies-directory (concat qz/notes-directory "daily/"))
#+end_src

#+RESULTS:
: ~/life/roam/daily/

** org-fragtog :init:func:
#+begin_src emacs-lisp
(require 'org-fragtog)
(add-hook 'org-mode-hook 'org-fragtog-mode)
#+end_src

** org-auto-tangle :init:
#+begin_src emacs-lisp
(require 'org-auto-tangle)
(add-hook 'org-mode-hook 'org-auto-tangle-mode)
#+end_src
** org-jira :vars:
set in authinfo.el
** org-habit
** [[id:d904ace6-a941-49fc-a6d4-7fe3797b0d8e][org-agenda]]
*** init :init:
- refiling targets
  - read (book, article, paper, research)
  - watch (film, youtube, etc)
  - wip (any)
  - views
  - overview
    - scheduled, deadlines, time-based
    - top of the list
    - processing

  - work (people)
  - doing (book, paper, article, research, wip)

#+begin_src emacs-lisp
(defvar qz/agenda-daily-files nil)

(use-package! org-agenda
  :init
  (map! "<f1>" #'qz/switch-to-agenda)
  (setq org-agenda-block-separator nil
        org-agenda-start-with-log-mode t
        org-agenda-files (list qz/org-agenda-directory))
  (defun qz/switch-to-agenda ()
    (interactive)
    (org-agenda nil "g"))
  :config
  (setq org-columns-default-format
        "%40ITEM(Task) %Effort(EE){:} LOCKSUM(Time Spent) %SCHEDULED(Scheduled) %DEADLINE(Deadline)")
  (setq org-agenda-custom-commands
        `(
          ("d" "Upcoming deadlines" agenda ""
           ((org-agenda-time-grid nil)
            (org-deadline-warning-days 365)        ;; [1]
            (org-agenda-entry-types '(:deadline))  ;; [2]
            ))
          ("ww" "wip all" tags "wip")
          ("wr" "wip reading" tags "wip+reading||wip+read|reading+next")
          ("hh" tags "+habit")
          ("P" "Printed agenda"
           ((agenda "" ((org-agenda-span 7)                      ;; overview of appointments
                        (org-agenda-start-on-weekday nil)         ;; calendar begins today
                        (org-agenda-repeating-timestamp-show-all t)
                        (org-agenda-entry-types '(:timestamp :sexp))))
            (agenda "" ((org-agenda-span 1)                      ; daily agenda
                        (org-deadline-warning-days 7)            ; 7 day advanced warning for deadlines
                        (org-agenda-todo-keyword-format "[ ]")
                        (org-agenda-scheduled-leaders '("" ""))
                        (org-agenda-prefix-format "%t%s")))
            (todo "TODO"                                          ;; todos sorted by context
                  ((org-agenda-prefix-format "[ ] %T: ")
                   (org-agenda-sorting-strategy '(tag-up priority-down))
                   (org-agenda-todo-keyword-format "")
                   (org-agenda-overriding-header "\nTasks by Context\n------------------\n"))))
           ((org-agenda-with-colors nil)
            (org-agenda-compact-blocks t)
            (org-agenda-remove-tags t)
            (ps-number-of-columns 2)
            (ps-landscape-mode t))
           ("~/agenda.ps"))
          ;; other commands go here
          )))

                                        ;(defun qz/rg-get-files-with-tags ()
                                        ;  "Returns a LIST of files that contain TAGS (currently, just `TODO')"
                                        ;  (split-string
                                        ;   (shell-command-to-string "rg TODO ~/life/roam/ -c | awk -F '[,:]' '{print $1}'")))
                                        ;
                                        ;(setq org-agenda-files
                                        ;      (append org-agenda-files (qz/rg-get-files-with-tags)))

#+end_src

#+RESULTS:
: t

*** Vulpea's category agenda refinement :org:
#+begin_src elisp
(setq qz/org-agenda-prefix-length 20
      org-agenda-prefix-format nil)
      ;; '((agenda . " %i Emacs Configuration %?-12t% s")
      ;;   (todo . " %i Emacs Configuration  ")
      ;;   (tags . " %i Emacs Configuration  ")
      ;;   (search . " %i Emacs Configuration  ")))

(defun vulpea-agenda-category (&optional len)
  "Get category of item at point for agenda.

Category is defined by one of the following items:
- CATEGORY property
- TITLE keyword
- TITLE property
- filename without directory and extension

When LEN is a number, resulting string is padded right with
spaces and then truncated with ... on the right if result is
longer than LEN.

Usage example:

  (setq org-agenda-prefix-format
        '((agenda . \" Emacs Configuration %?-12t %12s\")))

Refer to `org-agenda-prefix-format' for more information."
  (let* ((file-name (when buffer-file-name
                      (file-name-sans-extension
                       (file-name-nondirectory buffer-file-name))))
         (title (qz/node-title))
         (category (org-get-category))
         (result
          (or (if (and
                   title
                   (string-equal category file-name))
                  title
                category)
              "")))
    (if (numberp len)
        (s-truncate len (s-pad-right len " " result))
      result)))
#+end_src

#+RESULTS:
: vulpea-agenda-category
*** agenda view, gtd :func:vars:
#+begin_src emacs-lisp
(defun qz/org-agenda-gtd ()
  (interactive)
  (org-agenda nil "g")
  (goto-char (point-min))
  (org-agenda-goto-today))

(setq org-agenda-custom-commands nil)
(add-to-list
 'org-agenda-custom-commands
 `("g" "GTD"
   ((agenda "" ((org-agenda-span 'day) (org-deadline-warning-days 60)))
    (tags-todo "wip"
               ((org-agenda-overriding-header "wip")))
    (todo "TODO"
          ((org-agenda-overriding-header "to process")
           (org-agenda-files '(,(concat qz/org-agenda-directory "inbox.org")))))
    (todo "TODO"
          ((org-agenda-overriding-header "daily inbox")
           (org-agenda-files qz/agenda-daily-files)))
    (todo "TODO"
          ((org-agenda-overriding-header "emails")
           (org-agenda-files '(,(concat qz/org-agenda-directory "emails.org")))))
    (todo "TODO"
          ((org-agenda-overriding-header "one-off Tasks")
           (org-agenda-files '(,(concat qz/org-agenda-directory "next.org"))))))))
    ;;        (org-agenda-skip-function '(org-agenda-skip-entry-if 'deadline 'scheduled))))

(qz/pprint org-agenda-custom-commands)
#+end_src

#+RESULTS:
#+begin_example

(("g" "GTD"
  ((agenda "" ((org-agenda-span 'day) (org-deadline-warning-days 60)))
   (tags-todo "wip" ((org-agenda-overriding-header "wip")))
   (todo "TODO"
         ((org-agenda-overriding-header "to process")
          (org-agenda-files '("~/life/roam/inbox.org"))))
   (todo "TODO"
         ((org-agenda-overriding-header "daily inbox")
          (org-agenda-files qz/agenda-daily-files)))
   (todo "TODO"
         ((org-agenda-overriding-header "emails")
          (org-agenda-files '("~/life/roam/emails.org"))))
   (todo "TODO"
         ((org-agenda-overriding-header "one-off Tasks")
          (org-agenda-files '("~/life/roam/next.org")))))))
#+end_example

*** safer org defer whaever

#+begin_src emacs-lisp
 (defun +org-defer-mode-in-agenda-buffers-h ()
      "`org-agenda' opens temporary, incomplete org-mode buffers.
I've disabled a lot of org-mode's startup processes for these invisible buffers
to speed them up (in `+org--exclude-agenda-buffers-from-recentf-a'). However, if
the user tries to visit one of these buffers they'll see a gimped, half-broken
org buffer. To avoid that, restart `org-mode' when they're switched to so they
can grow up to be fully-fledged org-mode buffers."
      (dolist (buffer org-agenda-new-buffers)
        (when (buffer-live-p buffer)
          (with-current-buffer buffer
            (add-hook 'doom-switch-buffer-hook #'+org--restart-mode-h
                      nil 'local)))))
#+end_src

#+RESULTS:
: +org-defer-mode-in-agenda-buffers-h

*** agenda view, shopping :func:vars:
#+begin_src emacs-lisp
(add-to-list
 'org-agenda-custom-commands
 '("ms" "shopping" tags "buy"))
#+end_src
#+RESULTS:
| ms | shopping | tags                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  | buy |
| g  | GTD      | ((agenda  ((org-agenda-span 'day) (org-deadline-warning-days 60))) (tags-todo wip ((org-agenda-overriding-header wip))) (todo TODO ((org-agenda-overriding-header to process) (org-agenda-files '(~/life/roam/inbox.org)))) (todo TODO ((org-agenda-overriding-header daily inbox) (org-agenda-files qz/agenda-daily-files))) (todo TODO ((org-agenda-overriding-header emails) (org-agenda-files '(~/life/roam/emails.org)))) (todo TODO ((org-agenda-overriding-header one-off Tasks) (org-agenda-files '(~/life/roam/next.org))))) |     |

*** agenda view, TODO :func:
#+begin_src emacs-lisp
(defun qz/org-agenda-todo ()
  (interactive)
  (org-agenda nil "t"))
#+end_src

#+RESULTS:
: qz/org-agenda-todo

*** TODO agenda view, wip
*** TODO agenda view, calendar
*** org-agenda-mode-map :kbd:
#+begin_src emacs-lisp
(map! :map org-agenda-mode-map
      "J" #'qz/org-agenda-process-inbox
      "C-j" #'qz/org-agenda-process-item
      "R" #'org-agenda-refile)
#+end_src

#+RESULTS:
*** process agenda item :func:
- Give the task some location context. Tagging the task with tags @work and
  @home means I can work on this appropriately
- Give the task a priority level, between A, B, and C. Hereâs how I decide a
  priority. Itâs a pretty loose dichotomy, but works for me.
  - A: Tasks that must get done regardless.
  - B: Tasks that should get done, but only after Priority A tasks.
  - C: Tasks that are good to get done, but not compulsory.
- Give the task an effort estimate. This is in the format HH:MM, if the task is
  estimated to take days, perhaps it needs to be broken down further.
- Refile the item. Here my tasks get assigned to a selection from relevant
  refile targets.

#+begin_src emacs-lisp
(setq org-agenda-bulk-custom-functions '((?b . #'qz/org-agenda-process-item)))

(defun qz/org-agenda-process-item ()
  "Process a single item in the org-agenda."
  (interactive)
  (org-with-wide-buffer
   (org-agenda-set-tags)
   (org-agenda-priority)
   (org-agenda-refile nil nil t)))
#+end_src

#+RESULTS:
: qz/org-agenda-process-item

*** TODO processing bulk agenda :func:
#+begin_src emacs-lisp
(defun qz/org-process-inbox ()
  "Called in org-agenda-mode, processes all inbox items."
  (interactive)
  (org-agenda-bulk-mark-regexp "inbox:")
  (org-agenda-bulk-action ?b))
#+end_src

#+RESULTS:
: qz/org-process-inbox
*** tags
#+begin_src emacs-lisp
(setq org-tag-alist
      '(("@errand" . ?e)
        ("@work" . ?w)
        ("@home" . ?h)
        ("@blog" . ?B)
        (:newline)
        ("emacs" . ?E)
        ("wip" . ?W)
        ("CANCELLED" . ?c)
        (:newline)
        ("learning" . ?l)
        ("research" . ?r)
        (:newline)
        (:newline)
        ("book" . ?b)
        ("article" . ?a)
        ("paper" . ?p)
        (:newline)
        (:newline)
        ("talk" . ?t)
        ("film" . ?f)))
#+end_src

#+RESULTS:
: ((@errand . 101) (@work . 119) (@home . 104) (@blog . 66) (:newline) (emacs . 69) (wip . 87) (CANCELLED . 99) (:newline) (learning . 108) (research . 114) (:newline) (:newline) (book . 98) (article . 97) (paper . 112) (:newline) (:newline) (talk . 116) (film . 102))


** org-gcal
*** secret properties :vars:
set in authinfo.el


** refile :vars:
#+begin_src emacs-lisp
(setq org-refile-targets '(("next.org" :level . 0)
                           ("reading.org" :level . 0)
                           ("watching.org" :level . 0)
                           ("learning.org" :level . 0)
                           ("inbox.org" :level . 0)
                           ("wip.org" :level . 1 )))
#+end_src

#+RESULTS:
: ((next.org :level . 0) (reading.org :level . 0) (watching.org :level . 0) (learning.org :level . 0) (wip.org :level . 1))

** [[id:6baf4bff-d5fe-4ce0-a130-0464e49de67d][org-mode]] :init:vars:
#+begin_src emacs-lisp :results none
(use-package! org
  :mode ("\\.org\\'" . org-mode)
  :init
  (map! :leader
        :prefix "n"
        "l" #'org-capture)
  (map! :map org-mode-map
        "M-n" #'outline-next-visible-heading
        "M-p" #'outline-previous-visible-heading
        "C->" #'org-do-demote
        "C-<" #'org-do-promote)
  (setq org-src-window-setup 'current-window
        org-return-follows-link t
        org-babel-load-languages '((emacs-lisp . t)
                                   (jupyter . t)
                                   (lisp . t)
                                   (python . t)
                                   (R . t))
        org-ellipsis " â¼ "
        org-confirm-babel-evaluate nil
        org-use-speed-commands t
        org-catch-invisible-edits 'show
        org-preview-latex-image-directory "/tmp/ltximg/"
        ;; ORG SRC BLOCKS {C-c C-,}
        org-structure-template-alist '(("q" . "quote")
                                       ("d" . "definition")
                                       ("s" . "src")
                                       ("sb" . "src bash")
                                       ("sp" . "src psql")
                                       ("sr" . "src R")
                                       ("ss" . "src ")
                                       ("jp" . "src jupyter-python")
                                       ("jr" . "src jupyter-R")
                                       ("el" . "src emacs-lisp")))
  (with-eval-after-load 'flycheck
    (flycheck-add-mode 'proselint 'org-mode)))
#+end_src


*** org-mode-hook -> org-fragtog
#+begin_src emacs-lisp
(add-hook 'org-mode-hook 'org-fragtog-mode)
#+end_src


** org-habit
#+begin_src emacs-lisp
(require 'org-habit)
#+end_src

#+RESULTS:
: org-habit

** org-jira :vars:
set in authinfo.el
** org-auto-tangle :init:
#+begin_src emacs-lisp
(require 'org-auto-tangle)
(add-hook 'org-mode-hook 'org-auto-tangle-mode)
#+end_src

#+RESULTS:
| org-auto-tangle-mode | org-fragtog-mode | er/add-org-mode-expansions | +lookup--init-org-mode-handlers-h | (closure (t) (&rest _) (add-hook 'before-save-hook 'org-encrypt-entries nil t)) | #[0 \301\211\207 [imenu-create-index-function org-imenu-get-tree] 2] | #[0 \300\301\302\303\304$\207 [add-hook change-major-mode-hook org-show-all append local] 5] | #[0 \300\301\302\303\304$\207 [add-hook change-major-mode-hook org-babel-show-result-all append local] 5] | org-babel-result-hide-spec | org-babel-hide-all-hashes | doom-disable-show-paren-mode-h | doom-disable-show-trailing-whitespace-h | +org-enable-auto-reformat-tables-h | +org-enable-auto-update-cookies-h | +org-make-last-point-visible-h | toc-org-enable | org-eldoc-load | +literate-enable-recompile-h |

** [[id:1c286bfc-c63b-48dc-a18c-61a1c139feaf][org-recoll]]
*** Initialisation :init:vars:

#+begin_src emacs-lisp
(require 'org-recoll)

(setq org-recoll-command-invocation "recollq -t -A"
      org-recoll-results-num 100)
#+end_src

#+RESULTS:
: 100

*** Bindings :kbd:
#+begin_src emacs-lisp
(map! "C-c g" #'org-recoll-search)
(map! "C-c u" #'org-recoll-update-index)
(map! :mode org-recoll-mode "q" #'kill-this-buffer)
#+end_src

#+RESULTS:

** org-protocol :init:
#+begin_src emacs-lisp
(require 'org-protocol)
#+end_src

#+RESULTS:
: org-protocol

** org-capture
*** browser boy
#+begin_src javascript :tangle no
javascript:location.href =
    'org-protocol://capture?template=c'
    + '&url='   + encodeURIComponent(location.href)
    + '&title=' + encodeURIComponent(document.title)
    + '&body='  + encodeURIComponent(window.getSelection());
#+end_src
*** TODO templates :init:vars:
#+begin_src emacs-lisp
(require 'org-capture)

(setq qz/capture-title-timestamp "20210813T161035Z-${slug}")

;; ORG ROAM BREAKS COMPAT WITH ORG CATURE BY REQUIRING '.ORG' IN FILE

(setq org-capture-templates
      `(("i" "inbox" entry
         (file ,(concat qz/org-agenda-directory "inbox.org"))
         "* TODO %? \nCREATED: %u\nFROM: %a")
        ;; spanish language capturing
        ("v" "vocab; spanish" entry
         (file+headline ,(concat qz/notes-directory "spanish_language.org") "vocab, phrases")
         "** \"%?\" :es:\nFROM: %a\n\n*** :en:\n")
        ;; capture link to live `org-roam' thing
        ("n" "now, as in NOW" entry (file ,(concat qz/org-agenda-directory "wip.org"))
         "* TODO [#A1] %? \nDEADLINE: %T\nCREATED: %u")
        ;; fire directly into inbox
        ("c" "org-protocol-capture" entry (file ,(concat qz/org-agenda-directory "inbox.org"))
         "* TODO [[%:link][%:description]]\nCREATED: %u\n\n#+begin_quote\n\n%i\n\n#+end_quote"
         :immediate-finish t)
        ;; push last captured item into inbox
        ("l" "last-capture" entry (file ,(concat qz/org-agenda-directory "inbox.org"))
         (function qz/inbox-last-captured)
         :immediate-finish t)
        ("I" "current-roam" entry (file ,(concat qz/org-agenda-directory "inbox.org"))
         (function qz/current-roam-link)
         :immediate-finish t)
        ("t" "tangent" entry (file ,(concat org-roam-dailies-directory (format-time-string "private-%Y-%m-%d.org")))
         "* TANGENT [%<%H:%M>] %?\nCREATED: %u\nFROM: %a")
        ("w" "weekly review" entry
         (file+datetree ,(concat qz/org-agenda-directory "reviews.org"))
         (file ,(concat qz/org-agenda-directory "templates/weekly_review.org")))))
#+end_src

#+RESULTS:
| i | inbox | entry | (file ~/life/roam/inbox.org) | * TODO %? |
*** TODO write last captured to inbox :func:
#+begin_src emacs-lisp
(defun qz/inbox-last-captured (&optional buffer)
  (interactive)
  (when-let ((b (or (and org-capture-last-stored-marker
                         (marker-buffer org-capture-last-stored-marker))
                    buffer)))
    (with-current-buffer b
      (org-goto-marker-or-bmk org-capture-last-stored-marker)
      (concat "* [[id:" (org-roam-id-at-point)  "][" (qz/node-title) "]]"))))

(defun qz/capture-last-captured ()
  (interactive)
  (when-let ((b (and org-capture-last-stored-marker
                     (marker-buffer org-capture-last-stored-marker))))
    (if (with-current-buffer b
          (not (string-equal "inbox" (qz/node-title))))
        (org-capture nil "l")
      (message "qz/capture-last-captured: skipping; last capture was inbox"))))
#+end_src

#+RESULTS:
: qz/capture-last-captured



*** FIXME doom org half-loaded buffer hack
https://github.com/hlissner/doom-emacs/issues/4832

#+begin_src emacs-lisp
(advice-add
 #'org-capture :around
 (lambda (fun &rest args)
   (letf! ((#'+org--restart-mode-h #'ignore))
     (apply fun args))))
#+end_src

#+RESULTS:
*** TODO weekly review
for [[id:e2c8c6b3-37a7-48d0-ae21-c78283dfb6e1][reviews]]

*** capture convenience functions :func:
#+begin_src emacs-lisp
;; helper capture function for `org-roam' for `agenda-mode'
(defun qz/current-roam-link ()
  (interactive)
  "Get link to org-roam file with title"
  (concat "* TODO [[" (buffer-file-name) "][" (qz/node-title) "]]"))

(defun qz/org-inbox-capture ()
  (interactive)
  "Capture a task in agenda mode."
  (org-capture nil "i"))

(defun qz/org-daily-tangent-capture ()
  (interactive)
  "Capture the inevitable tangent"
  (org-capture nil "t"))

(defun qz/org-roam-capture-current ()
  (interactive)
  "Capture a task in agenda mode."
  (org-capture nil "I"))

(defun qz/roam-capture-todo ()
  (interactive)
  "Capture a task in agenda mode."
  (destructuring-bind (thing region) (qz/thing-at-point-or-region-and-region)
    (org-roam-capture- :goto t
                       :keys "n"
                       :node (org-roam-node-create :title thing)
                       :props `(:immediate-finish t :jump-to-captured nil
                                :region ,region     :insert-at ,(point-marker)
                                :finalize 'insert-link))
    (qz/capture-last-captured)))

#+end_src

#+RESULTS:
: qz/roam-capture-todo


*** TODO check if file has links to given note :func:
[[file:../../../life/roam/20210422T104455Z-org_roam_database_machinations.org][org-roam database machinations]]

#+begin_src emacs-lisp
(defun qz/org-roam-has-link-to-p (source dest)
  "TODO implement; returns t/nil if source links to dest"
  nil)
#+end_src

#+RESULTS:
: qz/roam-capture-todo
** [[id:3496a6b3-8ec5-431c-b50b-bd948e35d1cf][org-gcal]]
*** secret properties :vars:
set in authinfo.el

*** files :vars:
#+begin_src emacs-lisp :results none
(ignore-errors
  (setq org-gcal-fetch-file-alist
      `((,qz/calendar-home . ,(concat qz/notes-directory "calendar-home.org"))
        (,qz/calendar-work . ,(concat qz/notes-directory "calendar-work.org"))
        (,qz/calendar-shared . ,(concat qz/notes-directory "calendar-shared.org"))))
  (qz/pprint org-gcal-fetch-file-alist))
#+end_src

*** recurring events headlines
#+begin_src emacs-lisp
(setq org-gcal-recurring-events-mode 'nested)
#+end_src

#+RESULTS:

: qz/org-roam-add-tag

*** TODO auto establish meta :func:
*** TODO auto tag youtube videos; fix for v2
#+begin_src emacs-lisp
(defun qz/format-link-from-title (title)
  (let ((file (org-roam-link--get-file-from-title title)))
    (and file (org-roam-format-link file title))))

(defun qz/roam-auto-youtube-video ()
  (interactive)
  (let ((key (+org--get-property "roam_key")))
    (when (string-match "YouTube" key)
      (let*
        ((channel+url (qz/roam-key->yt-channel key))
         (link (qz/format-link-from-title (first channel+url)))
         (channel (or link (concat "[[roam:" (first channel+url) "]]")))
         (str
          (concat "A "
                  (qz/format-link-from-title "YouTube") " "
                  (qz/format-link-from-title "video") " from "
                  channel)))
        (insert str)))))
#+end_src

#+RESULTS:
: qz/roam-auto-youtube-video


*** TODO scrape youtube channel

#+begin_src emacs-lisp
(defun qz/roam-key->yt-channel (key)
  (let ((str (shell-command-to-string
              (concat
               "youtube-dl " key "--skip-download --dump-json | "
               "python -c 'import sys;import json;b=json.loads(sys.stdin.read());print(b.get(\"channel\")+\",\"+b.get(\"channel_url\"))'"))))
    (message str)
    (and str (split-string str ","))))

;(qz/roam-key->yt-channel "https://www.youtube.com/watch?v=KopB4l5QkEg")
#+end_src

#+RESULTS:
| HexiBase | https://www.youtube.com/channel/UCtpB66XKjAtFZfZyzmC-_Cg |


**** what a journey
#+begin_src bash :results drawer :tangle no
youtube-dl --skip-download --dump-json https://www.youtube.com/watch?v=KopB4l5QkEg | python -c 'import json;import sys;print(json.loads(sys.stdin.read()).get("channel"))'
#+end_src

#+RESULTS:
:results:
HexiBase
:end:


#+begin_src python  :results output :tangle no
import json
c = None
with open('./ytdl.json') as f:
    c = json.loads(f.read())

print(c.get('channel'))
#+end_src

#+RESULTS:
: HexiBase


*** TODO Run analysis :func:
Run analysis from source file on org-roam DB
- restrict graph (e.g. exclude sensitive information)
*** headline parsing function
#+begin_src emacs-lisp
(defun qz/get-headline-path (&optional self? reverse? sepf)
  (interactive)
  (let* ((s (or sepf
                (lambda (i)
                  (if (< 0 i) " -> " ""))))
         (c (org-get-outline-path self?)))
    (insert "\n")
    (cl-loop
     for e in (if reverse? (reverse c) c)
     for i = 0 then (1+ i)
     do (insert (funcall s i) e))))
#+end_src
** [[id:b33372ae-f731-4482-8e3a-0c5e986ac70a][org-roam]]
*** V1 Initialisation :init:vars:
#+begin_src emacs-lisp :tangle no
(use-package! org-roam
  :commands (org-roam-insert org-roam-find-file org-roam-switch-to-buffer org-roam)
  :hook
  (after-init . org-roam-mode)
  :custom-face
  (org-roam-link ((t (:inherit org-link :foreground "#df85ff"))))
  :init
  (map! :leader
        :prefix "n"
        :desc "org-roam" "l" #'org-roam
        :desc "org-roam-switch-to-buffer" "b" #'org-roam-switch-to-buffer
        :desc "org-roam-find-file" "f" #'org-roam-find-file
        :desc "org-roam-insert" "i" #'qz/roam-insert
        :desc "org-agenda-todo" "t" #'qz/org-agenda-todo
        :desc "org-roam-dailies-today" "J" #'org-roam-dailies-today
        :desc "org-roam-dailies-capture-today" "j" #'org-roam-dailies-capture-today
        :desc "qz/org-roam-capture-current" "C" #'qz/org-roam-capture-current
        :desc "qz/org-roam-capture-current" "C-c" #'qz/org-roam-capture-current
        :desc "qz/org-gcal--current" "C-c" #'qz/org-roam-capture-current
        :desc "org-roam-capture" "c" #'org-roam-capture)
  (setq org-roam-directory qz/notes-directory
        org-roam-dailies-directory qz/notes-directory
        org-roam-db-location (concat org-roam-directory "org-roam.db")
        org-roam-graph-executable "dot"
        org-roam-graph-extra-config '(("overlap" . "false"))
        org-roam-graph-exclude-matcher nil)

  :config
  (require 'org-roam-protocol))

(org-roam-mode +1)
#+end_src

#+RESULTS:
: t

*** V2 Initialisation :init:vars:
#+begin_src emacs-lisp
(setq org-roam-v2-ack t)
(use-package! org-roam
  :after org
  :commands
  (org-roam-buffer
   org-roam-setup
   org-roam-capture
   org-roam-node-find)
  :init
  (map! :leader
        :prefix "n"
        :desc "org-roam" "l" #'org-roam-buffer-toggle
        :desc "org-roam: capture entry today" "j" #'org-roam-dailies-capture-today
        :desc "org-roam: go to today" "J" #'org-roam-dailies-find-today
        :desc "org-roam: go to today" "C-j" #'qz/org-daily-tangent-capture
        :desc "org-roam-node-insert" "i" #'org-roam-node-insert
        :desc "qz/org-roam-immediate-node-insert" "C-i" #'qz/org-roam-immediate-node-insert
        :desc "org-roam-node-find" "f" #'org-roam-node-find)
  :config
  (setq org-roam-mode-sections
       (list #'org-roam-backlinks-insert-section
             #'org-roam-reflinks-insert-section
             #'org-roam-unlinked-references-insert-section)
        org-roam-graph-executable "neato"
        org-roam-graph-extra-config '(("overlap" . "false")))
  (org-roam-setup))
(use-package! org-roam-protocol
  :after org-protocol)

#+end_src

#+RESULTS:
: org-roam-protocol

*** V2 migration
**** ids, file links
:PROPERTIES:
:ID:       57e02885-17bb-44a0-9b97-249cfb8053e6
:END:
from https://github.com/org-roam/org-roam/issues/1091#issuecomment-703531409
#+begin_src emacs-lisp
(defun my/replace-file-with-id-link ()
  "Replaces file links with ID links where possible in current buffer."
  (interactive)
  (let (path desc)
    (org-with-point-at 1
      (while (re-search-forward org-link-bracket-re nil t)
        (setq desc (match-string 2))
        (when-let ((link (save-match-data (org-element-lineage (org-element-context) '(link) t))))
          (when (string-equal "file" (org-element-property :type link))
            (setq path (expand-file-name (org-element-property :path link)))
            (replace-match "")
            (insert (org-roam-format-link path desc))))))))

(defun qz/or-migrate-v2 ()
  (dolist (file (org-roam--list-all-files))
    (with-current-buffer (or (find-buffer-visiting file)
                             (find-file-noselect file))
      (org-with-point-at 1
        (org-id-get-create))
      (save-buffer)))
  (org-roam-db-sync)
  (dolist (file (org-roam--list-all-files))
    (with-current-buffer (or (find-buffer-visiting file)
                             (find-file-noselect file))
      (my/replace-file-with-id-link)
      (save-buffer)))
  (org-roam-db-sync))

;;(qz/or-migrate-v2)
#+end_src

#+RESULTS:
: qz/or-migrate-v2
**** property migration life state d96167ff5a1adcb27e95ce7b0239b107fdd1a0f6
- for each roam file
  + collect #+roam_tags R -> '(a b)
  + collect #+filetags  F -> '(c d)
  + dedupe the results, set in standard property  ~(set-file-properties 'filetags (dedupe (concat R F)))~
  + save
#+begin_src emacs-lisp
(defun qz/or-migrate-filetags ()
  (dolist (file (seq-uniq
                 (append
                  (split-string-and-unquote
                   (shell-command-to-string "rg 'roam_tags' ~/life/roam -il"))
                  (split-string-and-unquote
                   (shell-command-to-string "rg 'filetags' ~/life/roam -il")))))
    (with-current-buffer (or (find-buffer-visiting file)
                             (find-file-noselect file))
      (org-with-point-at (point-min)
        (mapc (lambda (s)  (org-roam-tag-add s))
              (qz/get-old-tags)))
      (save-buffer)
      (kill-this-buffer))
    (shell-command-to-string "~/.local/bin/wrg '^\\#\\+roam_tags:.*' ~/life/roam/ -i --replace ''")))

(defun qz/get-old-tags ()
  (split-string-and-unquote
    (concat (+org-get-global-property "roam_tags")
            " "
            (+org-get-global-property "filetags"))))

;;(qz/or-migrate-filetags)

;;(length
;; (seq-uniq
;;  (append
;;   (split-string-and-unquote
;;    (shell-command-to-string "rg '^\\#\\+roam_tags: \\w' ~/life/roam/ -il"))
;;   (split-string-and-unquote
;;    (shell-command-to-string "rg 'filetags' ~/life/roam -l")))))
#+end_src

#+RESULTS:
: qz/get-old-tags
**** verify tags
***** pre distribution
#+begin_src sqlite :db ~/.emacs.d/org-roam.db :results drawer table :colnames yes :tangle no
select tag, count(tag)
from tags t
group by tag
#+end_src

#+RESULTS:
:results:
| tag    | count(tag) |
|--------+------------|
| @work  |          1 |
| emacs  |          1 |
| living |          1 |
| three  |          1 |
| week   |          1 |
| wip    |          1 |
:end:

***** post distribution
#+begin_src sqlite :db ~/.emacs.d/org-roam.db :results drawer table :colnames yes :tangle no
select tag, count(tag)
from tags t
group by tag
#+end_src

#+RESULTS:
:results:
| tag    | count(tag) |
|--------+------------|
| @work  |          1 |
| emacs  |          1 |
| living |          1 |
| three  |          1 |
| week   |          1 |
| wip    |          1 |
:end:
***** deep diving info loss

(find-file-literally "/home/qzdl/life/roam/private-2021-06-10.org")
(shell-command-to-string "cd ~/life/roam && git reset --hard d96167ff5a1adcb27e95ce7b0239b107fdd1a0f6")
(progn
  (qz/or-migrate-filetags)
  (org-roam-db-sync))

#+begin_src emacs-lisp :tangle no
(org-roam-db-sync)
(org-roam-db-query
 [:select [tag file title level]
  :from tags :as t
  :join nodes :as n
    :on (= n:id t:node_id)
  :where (like file "%german%")
  :limit 10
  ])
#+end_src
***** get files which are tagged
#+begin_src elisp :tangle no
(seq-uniq
 (append
  (split-string-and-unquote
   (shell-command-to-string "rg 'roam_tags' ~/life/roam -l"))
  (split-string-and-unquote
   (shell-command-to-string "rg 'filetags' ~/life/roam -l"))))
#+end_src


***** roam counts
#+begin_src bash :tangle no
rg '^\#\+roam_tags:' ~/life/roam/ -i --color never  | cut -d ':' -f 1 | grep '^[0-9]' > /tmp/roamcounts
rg '^\#\+filetags:' ~/life/roam/ -i --color never --column | cut -d ':' -f 1 | grep '^[0-9]'  >> /tmp/roamcounts
cat /tmp/roamcounts | wc -l | Rscript -e 'd<-scan("stdin", quiet=TRUE)' -e 'cat(min(d), max(d), median(d), mean(d), length(d), sep="\n")'

#+end_src

#+RESULTS:
| 0 |
| 0 |
| 0 |
| 0 |
| 1 |

*** capture templates :vars:
**** roam capture templates
:PROPERTIES:
:ID:       bc3c61d4-d720-40a8-9018-6357f05ae85e
:END:
#+begin_src emacs-lisp :results table
(setq qz/org-roam-capture-head "#+title: ${title}\n")
(setq qz/capture-title-timestamp-roam "20210813T161035Z-${slug}.org")

(setq org-roam-capture-templates
      `(("d" "default" plain "%?"
         :if-new (file+head ,qz/capture-title-timestamp-roam
                            ,qz/org-roam-capture-head)
         :unnarrowed t)
        ("n" "empty" plain "%?"
         :if-new (file+head ,qz/capture-title-timestamp-roam
                            ,qz/org-roam-capture-head)
         :immediate-finish t)
        ))
#+end_src

#+RESULTS:
| d | default | plain | %? | :if-new | (file+head 20210813T161035Z-${slug}.org #+title: ${title} |

**** protocol :vars:
#+begin_src emacs-lisp
(setq org-roam-capture-ref-templates
      `(("r" "ref" plain
         "%?"
         :if-new (file+head ,qz/capture-title-timestamp-roam
                            "#+title: ${title}\n")
         :unnarrowed t)))

#+end_src

#+RESULTS:
| r | ref | plain | %? | :if-new | (file+head 20210813T161035Z-${slug}.org #+title: ${title} |

**** dailies :vars:
#+begin_src emacs-lisp
(setq
 qz/org-roam-dailies-filespec "private-%<%Y-%m-%d>.org"
 org-roam-dailies-capture-templates
      `(("d" "default" plain
         "* [%<%H:%M>] %?\nCREATED: %u\nFROM: %a"
         :if-new (file+head ,qz/org-roam-dailies-filespec
                            "#+title: <%<%Y-%m-%d>>\n#+filetags: daily private\n\n"))))
#+end_src

#+RESULTS:
| d | default | plain | * [%<%H:%M>] %? |

*** helpers :func:
**** TODO point->roam-id; get id from node at point
#+begin_src emacs-lisp
(defun qz/point->roam-id (&optional pos)
  (org-roam-node-id (org-roam-node-at-point)))
#+end_src

#+RESULTS:
: qz/point->roam-id
**** daily-title-regexp :vars:
#+begin_src emacs-lisp
(setq qz/daily-title-regexp ".?[0-9]\\{4\\}-[0-9]\\{2\\}-[0-9]\\{2\\}.?")
#+end_src

#+RESULTS:
: .?[0-9]\{4\}-[0-9]\{2\}-[0-9]\{2\}.?

**** title->roam-id
#+begin_src emacs-lisp
(defun qz/title->roam-id (title)
  (org-roam-node-id (org-roam-node-from-title-or-alias title)))
#+end_src

#+RESULTS:
: qz/title->roam-id
**** node-title; get title from node (file or entry)
#+begin_src emacs-lisp
(defun qz/node-title (&optional limit)
  (save-excursion
    (goto-char (org-roam-node-point (qz/org-roam-node-at-point 'assert limit)))
    (if (= (org-outline-level) 0)
        (cadr (car (org-collect-keywords '("title"))))
      (substring-no-properties (org-get-heading t t t)))))

;(qz/node-title)
#+end_src

#+RESULTS:
: qz/node-title

**** node-tags;  get tags  from node (file or entry)
#+begin_src emacs-lisp
(defun qz/node-tags ()
  (save-excursion
    (goto-char (org-roam-node-point (org-roam-node-at-point 'assert)))
    (if (= (org-outline-level) 0)
        (split-string-and-unquote (or (cadr (car (org-collect-keywords '("filetags")))) ""))
      (org-get-tags))))

;(qz/node-tags)
#+end_src

#+RESULTS:
: qz/node-tags

**** sidestep node-read with *node-create
#+begin_src emacs-lisp :tangle no
(equal (org-roam-node-read) (org-roam-node-create :title "radarr")) ;; given the same input string
#+end_src

#+RESULTS:
: t

**** custom roam-insert :func:
if ~pass-thru~, then fire capture template from thing at point, to template "n"
of [[id:bc3c61d4-d720-40a8-9018-6357f05ae85e][roam-capture-template]]

#+begin_src emacs-lisp


(defun qz/roam-immediate-insert ()
  (interactive)
  (qz/org-roam-node-insert nil t))

(defun qz/thing-at-point-or-region-and-region (&optional thing prompt)
  "Grab the current selection, THING at point, or xref identifier at point.

Returns THING if it is a string. Otherwise, if nothing is found at point and
PROMPT is non-nil, prompt for a string (if PROMPT is a string it'll be used as
the prompting string). Returns nil if all else fails.

NOTE: Don't use THING for grabbing symbol-at-point. The xref fallback is smarter
in some cases."
  (declare (side-effect-free t))
  (cond ((stringp thing)
         thing)
        ((doom-region-active-p)
         (cons (buffer-substring-no-properties (region-beginning) (region-end))
               (cons (region-beginning)
                     (region-end))))
        (thing
         (cons (thing-at-point thing t)
               (bounds-of-thing-at-point thing)))
        ((require 'xref nil t)
         ;; Eglot, nox (a fork of eglot), and elpy implementations for
         ;; `xref-backend-identifier-at-point' betray the documented purpose of
         ;; the interface. Eglot/nox return a hardcoded string and elpy prepends
         ;; the line number to the symbol.
         (let* ((val
                 (if (memq (xref-find-backend) '(eglot elpy nox))
                     (thing-at-point 'symbol t)
                   ;; A little smarter than using `symbol-at-point', though in most
                   ;; cases, xref ends up using `symbol-at-point' anyway.
                   (xref-backend-identifier-at-point (xref-find-backend)))))
           (cons val (bounds-of-thing-at-point 'symbol))))
        (prompt
         (read-string (if (stringp prompt) prompt "")))))



(destructuring-bind (a . (b . c)) '(1  . (2 . 3))
  (message "%s %s %s" a b c))

(defun qz/org-roam-node-insert (&optional filter-fn pass-thru)
  "Find an Org-roam file, and insert a relative org link to it at point.
Return selected file if it exists.
If LOWERCASE is non-nil, downcase the link description.
FILTER-FN is the name of a function to apply on the candidates
which takes as its argument an alist of path-completions."
  (interactive)
  (unwind-protect
      ;; Group functions together to avoid inconsistent state on quit
      (atomic-change-group
        (let* ((pt (qz/thing-at-point-or-region-and-region))
               (beg (set-marker (make-marker) (car (cdr pt))))
               (end (set-marker (make-marker) (cdr (cdr pt))))
               (region-text (org-link-display-format
                             (substring-no-properties (car pt))))
               (node (if pass-thru
                         (or (org-roam-node-from-title-or-alias region-text)
                             (org-roam-node-create :title region-text))
                       (org-roam-node-read region-text filter-fn)))
               (description (or (and node region-text (org-roam-node-title node))
                                region-text)))
          (if (org-roam-node-id node)
              (progn
                (when region-text
                  (delete-region beg end)
                  (set-marker beg nil)
                  (set-marker end nil))
                (insert (org-link-make-string
                         (concat "id:" (org-roam-node-id node))
                         description)))
            (funcall
              `(lambda ()
                 (org-roam-capture-
                  :node node
                  ,@(when pass-thru '(:keys "n")) ; ; [[id:bc3c61d4-d720-40a8-9018-6357f05ae85e][roam-capture-template]]
                  :props (append
                          (when (and beg end)
                            (list :region (cons beg end)))
                          (list :insert-at (point-marker)
                                :link-description description
                                :finalize 'insert-link))))))))
    (deactivate-mark)))
#+end_src

#+RESULTS:
: qz/org-roam-node-insert
***** thing-at-point-or-region-and-region
#+begin_src emacs-lisp
(defun qz/thing-at-point-or-region-and-region (&optional thing prompt)
  "Grab the current selection, THING at point, or xref identifier at point.

Returns THING if it is a string. Otherwise, if nothing is found at point and
PROMPT is non-nil, prompt for a string (if PROMPT is a string it'll be used as
the prompting string). Returns nil if all else fails.

NOTE: Don't use THING for grabbing symbol-at-point. The xref fallback is smarter
in some cases."
  (declare (side-effect-free t))
  (cond ((stringp thing)
         thing)
        ((doom-region-active-p)
         (cons (buffer-substring-no-properties (region-beginning) (region-end))
               (cons (region-beginning)
                     (region-end))))
        (thing
         (cons (thing-at-point thing t)
               (bounds-of-thing-at-point thing)))
        ((require 'xref nil t)
         ;; Eglot, nox (a fork of eglot), and elpy implementations for
         ;; `xref-backend-identifier-at-point' betray the documented purpose of
         ;; the interface. Eglot/nox return a hardcoded string and elpy prepends
         ;; the line number to the symbol.
         (let* ((val
                 (if (memq (xref-find-backend) '(eglot elpy nox))
                     (thing-at-point 'symbol t)
                   ;; A little smarter than using `symbol-at-point', though in most
                   ;; cases, xref ends up using `symbol-at-point' anyway.
                   (xref-backend-identifier-at-point (xref-find-backend)))))
           (cons val (bounds-of-thing-at-point 'symbol))))
        (prompt
         (read-string (if (stringp prompt) prompt "")))))

#+end_src

#+RESULTS:
: qz/thing-at-point-or-region-and-region

***** org-roam-immediate-node-insert
#+begin_src emacs-lisp
(defun qz/org-roam-immediate-node-insert ()
"Insert a node on `thing-at-point', corresponding to the thing, creating
if not existing"
  (interactive)
  (qz/org-roam-node-insert nil t))
#+end_src

#+RESULTS:
: qz/org-roam-immediate-node-insert

***** org-roam-node-insert
#+begin_src emacs-lisp
(defun qz/org-roam-node-insert (&optional filter-fn pass-thru)
  "Find an Org-roam file, and insert a relative org link to it at point.
Return selected file if it exists.
If LOWERCASE is non-nil, downcase the link description.
FILTER-FN is the name of a function to apply on the candidates
which takes as its argument an alist of path-completions."
  (interactive)
  (unwind-protect
      ;; Group functions together to avoid inconsistent state on quit
      (atomic-change-group
        (let* ((pt (qz/thing-at-point-or-region-and-region))
               (beg (set-marker (make-marker) (car (cdr pt))))
               (end (set-marker (make-marker) (cdr (cdr pt))))
               (region-text (org-link-display-format
                             (substring-no-properties (car pt))))
               (node (if pass-thru
                         (or (org-roam-node-from-title-or-alias region-text)
                             (org-roam-node-create :title region-text))
                       (org-roam-node-read region-text filter-fn)))
               (description (or (and node region-text (org-roam-node-title node))
                                region-text)))
          (if (org-roam-node-id node)
              (progn
                (when region-text
                  (delete-region beg end)
                  (set-marker beg nil)
                  (set-marker end nil))
                (insert (org-link-make-string
                         (concat "id:" (org-roam-node-id node))
                         description)))
            (funcall
              `(lambda ()
                 (org-roam-capture-
                  :node node
                  ;; there could be a better way to reference the `immediate-finish'
                  ;; roam-capture-template here, but for demo it's just easier to splice in
                  ;; with a funny metaprogramming hack for conditional interning `:key "val"'
                  ,@(when pass-thru '(:keys "n"))  ; where "n" is an `immediate-finish' template
                  :props (append
                          (when (and beg end)
                            (list :region (cons beg end)))
                          (list :insert-at (point-marker)
                                :link-description description
                                :finalize 'insert-link))))))))
    (deactivate-mark)))
#+end_src

#+RESULTS:
: qz/org-roam-node-insert
**** custom node-at-point :func:
#+begin_src emacs-lisp
(defun qz/org-roam-node-at-point (&optional assert limit)
  "Return the node at point.
If ASSERT, throw an error if there is no node at point."
  (if-let ((node (magit-section-case
                   (org-roam-node-section (oref it node))
                   (t (let* (id
                             (count 0))
                        (org-with-wide-buffer
                         (while (and (not (setq id (org-id-get)))
                                     (if limit (< limit (setq count (1+ count))) t)
                                     (not (bobp)))
                           (org-roam-up-heading-or-point-min))
                         (when id
                           (org-roam-populate
                            (org-roam-node-create :id id
                                                  :point (point))))))))))
      node
    (when assert
      (user-error "No node at point"))))
#+end_src

#+RESULTS:
: qz/org-roam-node-at-point

**** qualify-node :func:

#+begin_src emacs-lisp
(defvar qz/roam-qualifier " => ")
(defvar qz/roam-qualifier-limit 1)

(defun qz/qualify-node (&optional qualifier limit)
  (interactive)
  (let (q)
    (save-excursion
      (when-let ((n (qz/node-title 0))) ;; get current title
        (org-roam-up-heading-or-point-min) ;; set point up to start search from above current
        (when-let ((pn (qz/org-roam-node-at-point nil (or limit qz/roam-qualifier-limit))))
          (setq q (message
                    (concat (org-roam-node-title pn)
                            (or qualifier qz/roam-qualifier)
                            n))))))
    (org-roam-alias-add q)
    (save-buffer)
    q))
#+end_src

#+RESULTS:
: qz/qualify-node

**** fixing wrong-type-argument hash-table-p nil
this plagued me for WEEKS
https://github.com/org-roam/org-roam/issues/1734
#+begin_src emacs-lisp :tangle no
(org-id-update-id-locations (directory-files-recursively org-roam-directory ".org$\\|.org.gpg$"))
#+end_src

*** data-driven automatic actions in org roam :project:
:PROPERTIES:  :project:person:
:ID:       6ae36e2f-ab6d-45bc-9448-8dce233c8528
:END:
'automatic' routines, pegged to file actions like 'visit, save' by way of advice
functions. inspired by [[https://d12frosted.io/posts/2020-06-25-task-management-with-roam-vol3.html][Task management with org-roam Vol. 3: FILETAGS]]

**** auto helpers :func:
***** title-to-tag
#+begin_src emacs-lisp
(defun qz/title-to-tag (title)
  "Convert TITLE to tag."
  (if (equal "@" (subseq title 0 1))
      title
    (concat "@" (s-replace " " "" title))))
#+end_src

#+RESULTS:
: qz/title-to-tag
***** refresh filetags cache
addressing caching & consistency problems with :PROPERTIES: drawer and #+properties

#+begin_src emacs-lisp
(defun qz/hard-refresh-org-tags-in-buffer ()
  (interactive)
  (setq org-file-tags nil)      ; blast the cache
  (org-set-regexps-and-options) ; regen property detection regexp
  (org-get-tags))               ; write to cache
#+end_src

#+RESULTS:
: qz/hard-refresh-org-tags-in-buffer
***** TODO get-file-by-tag; add multi AND/OR
#+begin_src emacs-lisp
(defun qz/roam-get-node-by-tag (tag)
  (seq-map
   #'car
   (org-roam-db-query
    [:select :distinct file
     :from tags
     :inner :join nodes
     :on (= tags:node_id nodes:id)
     :where (= tags:tag tag)])))
#+end_src

#+RESULTS:
: qz/roam-get-node-by-tag

***** should-be-private-p; interactive sanity check the current file for privacy
#+begin_src emacs-lisp
(defun qz/should-be-private-p (file)
  (with-current-buffer (or (find-buffer-visiting file)
                           (find-file-noselect file))
    (qz/private-p)))

(defun qz/is-file-private ()
  (interactive)
  (message (concat "should " (f-this-file) " be private..? "
                   (or (and (qz/should-be-private-p (f-this-file)) "yes") "no"))))
#+end_src

#+RESULTS:
: qz/is-file-private

***** project-files; for [[id:d904ace6-a941-49fc-a6d4-7fe3797b0d8e][org-agenda]] candidates :func:
:PROPERTIES:
:ID:       cb81cfd7-fb16-4965-af20-69129cf4fd97
:END:
#+begin_src emacs-lisp
(defun qz/project-files ()
  "Return a list of note files containing Project tag."
  (seq-map
   #'car
   (org-roam-db-query
    [:select :distinct file
     :from tags
     :inner :join nodes
     :on (= tags:node_id nodes:id)
     :where (= tags:tag "project")])))


;(qz/project-files)
#+end_src

#+RESULTS:
: qz/project-files

***** daily-files; for [[id:d904ace6-a941-49fc-a6d4-7fe3797b0d8e][org-agenda]] candidates
#+begin_src emacs-lisp
(defun qz/agenda-daily-files-f ()
  (seq-filter (lambda (s) (string-match qz/daily-title-regexp s))
              org-agenda-files))
;(qz/agenda-daily-files-f)
#+end_src

#+RESULTS:
: qz/agenda-daily-files-f

***** migrate automatic :func:
#+begin_src emacs-lisp
(defun qz/org-roam-migrate-jobs ()
  (interactive )
  (dolist (file (org-roam--list-all-files))
    (with-current-buffer (or (find-buffer-visiting file)
                             (find-file-noselect file))
      (message "%s visiting" file)
      (qz/dispatch-hook)
      (save-buffer))))
;(qz/org-roam-migrate-jobs)
#+end_src

#+RESULTS:
: qz/org-roam-migrate-jobs
**** auto actions :func:
***** headine-add-tag
#+begin_src emacs-lisp
(defun qz/headline-add-tag (title)
  "add tag to headline for `title'"
  (save-excursion
    (ignore-errors
      (org-back-to-heading)
      (org-set-tags
       (seq-uniq
        (cons
         (qz/title-to-tag title)
         (org-get-tags nil t)))))))

#+end_src

#+RESULTS:

***** TODO ensure-tag
- check if this needs to manipulate the point
#+begin_src emacs-lisp
(defun qz/ensure-tag (tagstring tag)
  "Apply `org-roam-tag-add' for `tag' to node with existing tags
`tagstring'

HACK: using `re-search-backward' to jump back to applicable
point (implicitly, `point-min' for file-level; :PROPERTIES: drawer for
entry); covering 'inherited match'.

this could be updated to jump back, but only 'landing' final on
PROPERTIES with non-nil :ID:"
  (progn (message "ensuring tag for %s" tag)
         (org-roam-tag-add tag)))
#+end_src

#+RESULTS:
: qz/ensure-tag
***** agenda-files-update; for [[id:d904ace6-a941-49fc-a6d4-7fe3797b0d8e][org-agenda]] candidates
write generated values to ~org-agenda-files~, for [[id:cb81cfd7-fb16-4965-af20-69129cf4fd97][project-files; for org-agenda
candidates]]

#+begin_src emacs-lisp
(defun qz/agenda-files-update (&rest _)
  "Update the value of `org-agenda-files' with relevant candidates"
  (interactive)
  (setq org-agenda-files
        (seq-uniq (append qz/org-agenda-files (qz/project-files)))
        qz/agenda-daily-files (qz/agenda-daily-files-f)))

#+end_src

#+RESULTS:
: (qz/agenda-files-update)


**** auto predicates
***** TODO note-buffer-p
expand this for all files in roam thing

#+begin_src emacs-lisp
(defun qz/note-buffer-p (&rest _)
  "Return non-nil if the currently visited buffer is a note."
  (interactive)
  (and buffer-file-name
       (string-prefix-p
        (expand-file-name (file-name-as-directory org-roam-directory))
        (file-name-directory buffer-file-name))))
#+end_src

#+RESULTS:
: qz/note-buffer-p

***** file-has-todo-p
#+begin_src emacs-lisp
(defun qz/file-has-todo-p (&rest _)
  "Return non-nil if current buffer has any todo entry.

TODO entries marked as done are ignored, meaning the this
function returns nil if current buffer contains only completed
tasks.

(1) parse the buffer using org-element-parse-buffer. It
  returns an abstract syntax tree of the current Org buffer. But
  since we care only about headings, we ask it to return only them
  by passing a GRANULARITY parameter - 'headline. This makes
  things faster.

(2) Then we extract information about TODO keyword from
  headline AST, which contains a property we are interested in -
  :todo-type, which returns the type of TODO keyword according to
  org-todo-keywords - 'done, 'todo or nil (when keyword is not
  present).

(3) Now all we have to do is to check if the buffer list contains
  at least one keyword with 'todo type. We could use seq=find on
  the result of org-element-map, but it turns out that it provides
  an optional first-match argument that can be used for our needs."
  (org-with-wide-buffer
   (org-element-map                          ; (2)
       (org-element-parse-buffer 'headline) ; (1)
       'headline
     (lambda (h)
       (eq (org-element-property :todo-type h)
           'todo))
     nil 'first-match)))                     ; (3)

#+end_src

#+RESULTS:
: qz/file-has-todo-p
***** has-tag-person-p
#+begin_src emacs-lisp
(defun qz/has-tag-person-p (&rest tags)
  (message "has-tag-person-p %s" tags)
  (seq-contains-p tags "person"))
#+end_src

#+RESULTS:
: qz/has-tag-person-p

***** has-link-p
good for restricting to work stuff
#+begin_src emacs-lisp
(defun qz/has-link-p (a b)
  "undirected connection exists, from `src' to `dst'"
   (org-roam-db-query
    [:select [source dest]
     :from links
     :where (or (and (= dest a) (= source b))
                (and (= dest b) (= source a)))]))
#+end_src

#+RESULTS:
: qz/has-link-p

***** has-link-to-p
#+begin_src emacs-lisp
(defun qz/has-link-to-p (dst &optional src)
  "directed connection exists, from `src' to `dst'"
  (if-let ((nap (org-roam-node-at-point)))
      (let ((src (or src (org-roam-node-id nap))))
        (org-roam-db-query
         [:select source
          :from links
          :where (and (= dest $r1)
                      (= source $r2))]
         src dst))))
#+end_src

#+RESULTS:
: qz/has-link-to-p

***** private-p
might be better to use the file prop, but maybe we keep the message in to deem

#+begin_src emacs-lisp
(defun qz/private-p (&rest _)
  (interactive)
  (let ((title (qz/node-title)))
    (if (not title)
        (and (message "unable to evaluate privateness; no title") nil) ; return false (not private)
      (or (string-match-p qz/daily-title-regexp title) ; daily
          (string-match-p "meeting" title)                                    ; concerns a meeting
          (qz/has-link-to-p (qz/title->roam-id "thinkproject"))))))           ; concerns work
#+end_src

#+RESULTS:
: qz/private-p


**** auto (predicate . action)
thinking about using a macro for generating these lambdas & inverting control here

#+begin_src emacs-lisp
(setq qz/auto-buffer-action
      '((qz/file-has-todo-p  . (lambda (tagstring) (qz/ensure-tag tagstring "project")))
        (qz/private-p   . (lambda (tagstring) (qz/ensure-tag tagstring "private")))
        (qz/has-tag-person-p . (lambda (tagstring)
                                 (qz/ensure-tag tagstring (qz/title-to-tag (qz/node-title)))))))

;;(car (car qz/auto-buffer-action))
#+end_src

#+RESULTS:
| qz/file-has-todo-p  | lambda | (tagstring) | (qz/ensure-tag tagstring project)                           |
| qz/private-p        | lambda | (tagstring) | (qz/ensure-tag tagstring private)                           |
| qz/has-tag-person-p | lambda | (tagstring) | (qz/ensure-tag tagstring (qz/title-to-tag (qz/node-title))) |

**** auto hooks, dispatch
#+begin_src emacs-lisp
(defun qz/dispatch-hook ()
  "Dispatches actions in notes based on filetags given `qz/auto-tag-action'. Assumes current buffer"
  (interactive)
  (when (and (not (+org-capture-frame-p))
             (not (org-roam-capture-p))
             (qz/note-buffer-p))
    (when-let ((tags (qz/node-tags)))
      (mapc (lambda (tag+fun)
              (when (funcall (car tag+fun) tags)
                (funcall (cdr tag+fun) "")))
            qz/auto-buffer-action))))

(advice-add 'org-agenda :before #'qz/agenda-files-update)
(add-hook 'find-file-hook   #'qz/dispatch-hook)
(add-hook 'before-save-hook #'qz/dispatch-hook)
#+end_src

#+RESULTS:
| qz/dispatch-hook |

**** reset; clear automated tag addition filetags
**** emacsql + attribute looping
#+begin_src emacs-lisp
(defun qz/sqlite-row-col (table)
  (cl-loop
   for tuple in (org-roam-db-query
                 `[:select *
                   :from ,table
                   :limit 1])
   collect (cl-loop for attr in tuple
                    for heading in (org-roam-db-query
                                    `[:select name
                                      :from (funcall pragma_table_info ',table)
                                      :order-by cid :asc])
                    collect (cons (car heading) (or attr 'null)))))

;(qz/pprint (qz/sqlite-row-col 'links))
#+end_src
#+RESULTS:
: qz/sqlite-row-col

*** testing
#+begin_src emacs-lisp :tangle no
(qz/pprint
 (append qz/org-agenda-files (qz/project-files)))
#+end_src

#+RESULTS:
:
: ("/home/qzdl/life/roam/calendar-home.org" "/home/qzdl/life/roam/calendar-work.org"
:  "/home/qzdl/life/roam/schedule.org"
:  "/home/qzdl/life/roam/private-2020-08-03.org"
:  "/home/qzdl/life/roam/private-2020-08-03.org")

*** get list of private notes
#+begin_src emacs-lisp
(defun qz/org-roam-private-files ()
  "Return a list of note files containing tag =private="
  (seq-map
   #'car
   (org-roam-db-query
    [:select node_id
     :from tags
     :where (like tag (quote "%\"private\"%"))])))

;(qz/pprint (qz/org-roam-private-files))
#+end_src

#+RESULTS:
: qz/org-roam-private-files


*** TODO Run analysis :func:
Run analysis from source file on org-roam DB
- restrict graph (e.g. exclude sensitive information)
*** headline parsing function
#+begin_src emacs-lisp
(defun qz/get-headline-path (&optional self? reverse? sepf)
  (interactive)
  (let* ((s (or sepf
                (lambda (i)
                  (if (< 0 i) " -> " ""))))
         (c (org-get-outline-path self?)))
    (insert "\n")
    (cl-loop
     for e in (if reverse? (reverse c) c)
     for i = 0 then (1+ i)
     do (insert (funcall s i) e))))

(defun qz/headline-mm (i)
  (if (< 0 i)
      (concat "\n" (make-string i ?	)) ""))

;;(qz/get-headline-path t t 'qz/headline-mm)


;; (progn
;;   (qz/get-headline-path)
;;   (qz/get-headline-path nil t)
;;   (qz/get-headline-path t)
;;   (qz/get-headline-path t t)
;;   (qz/get-headline-path t t 'qz/headline-mm)
;;   (qz/get-headline-path t nil 'qz/headline-mm)
;;   (qz/get-headline-path nil nil 'qz/headline-mm))
#+end_src

#+RESULTS:
: qz/headline-mm
*** TODO transform an org subtree, into mindmap for ttmm :ttmm:
tab delimit
given a subtree (at point)

*** TODO query slice of headlines, containing REGEXP, build path with [[headline parsing function]]

*** org-roam-server :init:vars:
[[https://github.com/org-roam/org-roam-server][GitHub - org-roam/org-roam-server]]
#+begin_src emacs-lisp :tangle no
(use-package! org-roam-server
  :config
  (setq org-roam-server-host "127.0.0.1"
        org-roam-server-port 8080
        org-roam-server-export-inline-images t
        org-roam-server-authenticate nil
        org-roam-server-network-label-truncate t
        org-roam-server-network-label-truncate-length 60))
#+end_src

#+RESULTS:
: t

** org-noter
*** qz/insert-note :func:
#+begin_src emacs-lisp
(defun qz/org-noter-insert-note (notetext &optional precise-info)
  "Insert note associated with the current location.

This command will prompt for a title of the note and then insert
it in the notes buffer. When the input is empty, a title based on
`org-noter-default-heading-title' will be generated.

If there are other notes related to the current location, the
prompt will also suggest them. Depending on the value of the
variable `org-noter-closest-tipping-point', it may also suggest
the closest previous note.

PRECISE-INFO makes the new note associated with a more
specific location (see `org-noter-insert-precise-note' for more
info).

When you insert into an existing note and have text selected on
the document buffer, the variable `org-noter-insert-selected-text-inside-note'
defines if the text should be inserted inside the note."
  (interactive)
  (org-noter--with-valid-session
   (message "double yeet")
   (let* ((ast (org-noter--parse-root)) (contents (org-element-contents ast))
          (window (org-noter--get-notes-window 'force))
          (selected-text
           (cond
            ((eq (org-noter--session-doc-mode session) 'pdf-view-mode)
             (when (pdf-view-active-region-p)
               (mapconcat 'identity (pdf-view-active-region-text) ? )))

            ((eq (org-noter--session-doc-mode session) 'nov-mode)
             (when (region-active-p)
               (buffer-substring-no-properties (mark) (point))))))
          force-new
          (location (org-noter--doc-approx-location (or precise-info 'interactive) (gv-ref force-new)))
          (view-info (org-noter--get-view-info (org-noter--get-current-view) location)))

     (let ((inhibit-quit t))
       (with-local-quit
         (select-frame-set-input-focus (window-frame window))
         (select-window window)

         ;; IMPORTANT(nox): Need to be careful changing the next part, it is a bit
         ;; complicated to get it right...

         (let ((point (point))
               (minibuffer-local-completion-map org-noter--completing-read-keymap)
               collection default default-begin title selection
               (empty-lines-number (if org-noter-separate-notes-from-heading 2 1)))

           (cond
            ;; NOTE(nox): Both precise and without questions will create new notes
            ((or precise-info force-new)
             (setq default (and selected-text (replace-regexp-in-string "\n" " " selected-text))))
            (org-noter-insert-note-no-questions)
            (t
             (dolist (note-cons (org-noter--view-info-notes view-info))
               (let ((display (org-element-property :raw-value (car note-cons)))
                     (begin (org-element-property :begin (car note-cons))))
                 (push (cons display note-cons) collection)
                 (when (and (>= point begin) (> begin (or default-begin 0)))
                   (setq default display
                         default-begin begin))))))

           (setq collection (nreverse collection)
                 title (if org-noter-insert-note-no-questions
                           default
                         notetext)
                 selection (unless org-noter-insert-note-no-questions (cdr (assoc title collection))))

           (if selection
               ;; NOTE(nox): Inserting on an existing note
               (let* ((note (car selection))
                      (insert-before-element (cdr selection))
                      (has-content
                       (eq (org-element-map (org-element-contents note) org-element-all-elements
                             (lambda (element)
                               (if (org-noter--check-location-property element)
                                   'stop
                                 (not (memq (org-element-type element) '(section property-drawer)))))
                             nil t)
                           t)))
                 (when has-content (setq empty-lines-number 2))
                 (if insert-before-element
                     (goto-char (org-element-property :begin insert-before-element))
                   (goto-char (org-element-property :end note)))


                 (if (org-at-heading-p)
                     (progn
                       (org-N-empty-lines-before-current empty-lines-number)
                       (forward-line -1))
                   (unless (bolp) (insert "\n"))
                   (org-N-empty-lines-before-current (1- empty-lines-number)))

                 (when (and org-noter-insert-selected-text-inside-note selected-text) (insert selected-text)))

             ;; NOTE(nox): Inserting a new note
             (let ((reference-element-cons (org-noter--view-info-reference-for-insertion view-info))
                   level)
               (when (zerop (length title))
                 (setq title (replace-regexp-in-string (regexp-quote "$p$") (number-to-string (car location))
                                                       org-noter-default-heading-title)))

               (if reference-element-cons
                   (progn
                     (cond
                      ((eq (car reference-element-cons) 'before)
                       (goto-char (org-element-property :begin (cdr reference-element-cons))))
                      ((eq (car reference-element-cons) 'after)
                       (goto-char (org-element-property :end (cdr reference-element-cons)))))

                     ;; NOTE(nox): This is here to make the automatic "should insert blank" work better.
                     (when (org-at-heading-p) (backward-char))

                     (setq level (org-element-property :level (cdr reference-element-cons))))

                 (goto-char (org-element-map contents 'section
                              (lambda (section) (org-element-property :end section))
                              nil t org-element-all-elements))
                 (setq level (1+ (org-element-property :level ast))))

               ;; NOTE(nox): This is needed to insert in the right place
               (outline-show-entry)
               (org-noter--insert-heading level title empty-lines-number location)
               (when (org-noter--session-hide-other session) (org-overview))

               (setf (org-noter--session-num-notes-in-view session)
                     (1+ (org-noter--session-num-notes-in-view session)))))

           (org-show-set-visibility t)
           (org-cycle-hide-drawers 'all)
           (org-cycle-show-empty-lines t)))
       (when quit-flag
         ;; NOTE(nox): If this runs, it means the user quitted while creating a note, so
         ;; revert to the previous window.
         (select-frame-set-input-focus (org-noter--session-frame session))
         (select-window (get-buffer-window (org-noter--session-doc-buffer session))))))))
#+end_src

#+RESULTS:
: qz/org-noter-insert-note

*** TODO can we please AUTO/org-roam create a missing note?
See <link-to-elisp-doc 'org-noter-notes-search-path> and cry

** org-ref
https://github.com/jkitchin/org-ref
#+begin_src emacs-lisp
(require 'org-ref)
(setq reftex-bib-path  '("~/life/tex.bib")
      reftex-default-bibliography reftex-bib-path
      org-ref-default-bibliography reftex-bib-path)
#+end_src

#+RESULTS:
| ~/life/tex.bib |

** org-super-agenda
#+begin_src emacs-lisp
(require 'org-super-agenda)
#+end_src

** TODO [[id:44f5ec09-570d-45d1-9cdd-446331e0c26e][org-drill]]
** ox (export)
#+begin_src emacs-lisp
(require 'ox-reveal)
#+end_src

#+RESULTS:
: ox-reveal
* mathpix
#+begin_src emacs-lisp
(require 'mathpix)
(setq mathpix-screenshot-method "scrot -s %s")

(map! "C-c o m" #'qz/mathpix-screenshot)

;; add var capture, to save last result
(defun qz/mathpix-screenshot ()
  "Capture screenshot and send result to Mathpix API."
  (interactive)
  (let
      ((default-directory "~"))
    (make-directory
     (file-name-directory mathpix-screenshot-file)
     t)
    (if
        (functionp mathpix-screenshot-method)
        (funcall mathpix-screenshot-method mathpix-screenshot-file)
      (shell-command-to-string
       (format mathpix-screenshot-method mathpix-screenshot-file)))
    (if
        (file-exists-p mathpix-screenshot-file)
        (progn
          (insert
           (setq mathpix-last-result
                 (mathpix-get-result mathpix-screenshot-file)))
          (delete-file mathpix-screenshot-file)))))
#+end_src

#+RESULTS:
: qz/mathpix-screenshot

* TODO GNUs
Following [[https://www.emacswiki.org/emacs/GnusTutorial][EmacsWiki: Gnus Tutorial]]

* TODO completion
** orderless
ideally the ordering should account ~match, last-used, degree~
** TODO find out about company component delimiters for inputting spaces and stuff
#+begin_src emacs-lisp
                                        ;(require 'orderless)
                                        ;(setq completion-styles '(orderless))
                                        ;(icomplete-mode) ; optional but recommended!
                                        ;
                                        ;(setq orderless-component-separator "[ &]")
                                        ;(setq company-idle-delay 0.1
                                        ;      company-minimum-prefix-length 1)
                                        ;
                                        ; highlight matching parcnfts
;; (defun just-one-face (fn &rest args)
;;   (let ((orderless-match-faces [completions-common-part]))
;;     (apply fn args)))

;; (advice-add 'company-capf--candidates :around #'just-one-face)

;; (use-package! orderless
;;   :config
;;   (after! ivy
;;     (setq ivy-re-builders-alist '((t . orderless-ivy-re-builder)))))


(use-package! orderless
  :init
  (setq completion-styles '(orderless)
        completion-category-defaults nil
        completion-category-overrides '((file (styles . (partial-completion)))))
  :config
  (after! ivy
  (setq ivy-re-builders-alist '((t . orderless-ivy-re-builder)))))


;;(prescient-persist-mode 1)
;;(selectrum-prescient-mode 1)
;;(setq selectrum-refine-candidates-function #'orderless-filter)
;;(setq selectrum-highlight-candidates-function #'orderless-highlight-matches)
#+end_src

#+RESULTS:
: t
*

* funny applications
** ingredients
Some code wrapping [[id:bddbea79-f454-47d5-8505-f397d19c353f][schollz/ingredients]], outputting some [[id:6baf4bff-d5fe-4ce0-a130-0464e49de67d][org-mode]] heading & body
#+begin_src emacs-lisp
(setq qz/buffer-mod-commands '(qz/get-ingredients-mod-buffer))

(defun qz/get-ingredients-mod-buffer ()
  "scrape the website found in ROAM_KEY for ingredients,
outputting the result in the buffer at-point"
  (interactive)
  (let* ((c (current-buffer))
         (pt (point))
         (json-object-type 'hash-table)
         (json-array-type 'list)
         (json-key-type 'string)
         (jsono
          (json-read-from-string
           (shell-command-to-string
            (concat "~/.local/bin/ingredients " (+org--get-property "roam_key")))))
         (ingreds (gethash "ingredients" jsono)))
    (insert "* Ingredients\n")
    (insert
     (apply
      'concat
      (mapcar (lambda (e)
                (concat "- " (gethash "line" e)
                        " [" (number-to-string (gethash "cups" (gethash "measure" e)))
                        " cups]\n")) ingreds)))))

(defun qz/read-property-mod-buffer ()
 (interactive)
 (let* ((command (completing-read "command: " qz/buffer-mod-commands))
       (args (+org--get-property (completing-read "property: " org-default-properties))))
   (setq current-prefix-arg '(4))
   (shell-command (concat command " " args " &"))))
#+end_src

#+RESULTS:
: qz/read-property-mod-buffer
main -> widow
- tan1 -> refernce/window
  -tan1i -> ref/win
- tan2
